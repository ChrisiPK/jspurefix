{"version":3,"file":"json-helper.js","sourceRoot":"","sources":["../../src/util/json-helper.ts"],"names":[],"mappings":";;;AACA,uDAMgC;AAGhC,iCAAiC;AAEjC,qDAAgD;AAEhD,MAAa,UAAU;IAErB,YAA6B,WAA2B;QAA3B,gBAAW,GAAX,WAAW,CAAgB;QADxD,eAAU,GAAmB,IAAI,0BAAc,EAAE,CAAA;IAEjD,CAAC;IAEO,MAAM,CAAC,WAAW,CAAE,MAAoB,EAAE,KAA2B;QAC3E,IAAI,IAAI,GAAW,KAAK,CAAC,UAAU,CAAC,IAAI,CAAA;QACxC,IAAI,CAAC,GAAQ,MAAM,CAAC,IAAI,CAAC,CAAA;QACzB,IAAI,CAAC,IAAI,IAAI,EAAE;YACb,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;YACtB,IAAI,CAAC,KAAK,IAAI,EAAE;gBACd,IAAI,GAAG,KAAK,CAAC,IAAI,CAAA;aAClB;SACF;QACD,IAAI,CAAC,IAAI,IAAI,EAAE;YACb,OAAM;SACP;QACD,QAAQ,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE;YAChC,KAAK,kBAAO,CAAC,OAAO,CAAC,CAAC;gBACpB,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,CAAC,CAAA;gBACrC,MAAK;aACN;YAED,KAAK,kBAAO,CAAC,YAAY;gBACvB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;gBACnB,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAA;gBACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;gBAChB,MAAK;YAEP,KAAK,kBAAO,CAAC,WAAW,CAAC,CAAC;gBACxB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;gBACnB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAA;gBACzB,MAAK;aACN;YAED,KAAK,kBAAO,CAAC,WAAW,CAAC,CAAC;gBACxB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;gBACnB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAA;gBACzB,MAAK;aACN;YAED,KAAK,kBAAO,CAAC,SAAS,CAAC,CAAC;gBACtB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;gBACnB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAA;gBACzB,MAAK;aACN;YAED,KAAK,kBAAO,CAAC,KAAK,CAAC,CAAC;gBAClB,MAAM,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAA;gBAC5B,MAAK;aACN;YAED,KAAK,kBAAO,CAAC,GAAG,CAAC;YACjB,KAAK,kBAAO,CAAC,MAAM,CAAC,CAAC;gBACnB,MAAM,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAA;gBAC9B,MAAK;aACN;SACF;IACH,CAAC;IAEM,QAAQ,CAAE,QAAgB,EAAE,OAAe;QAChD,MAAM,GAAG,GAAiB,OAAO,CAAC,QAAQ,CAAC,CAAA;QAC3C,MAAM,GAAG,GAAsB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAA;QACpE,IAAI,CAAC,GAAG,EAAE;YACR,OAAO,GAAG,CAAA;SACX;QACD,IAAI,GAAG,CAAC,KAAK,EAAE;YACb,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAe,EAAE,EAAE;gBACpC,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;YAC9B,CAAC,CAAC,CAAA;SACH;aAAM;YACL,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;SAC/B;QACD,OAAO,GAAG,CAAA;IACZ,CAAC;IAEM,eAAe,CAAE,GAAsB,EAAE,MAAoB;QAClE,IAAI,CAAC,MAAM,EAAE;YACX,OAAM;SACP;QAED,MAAM,UAAU,GAAqB;YACnC,MAAM,EAAE,CAAC,KAA2B,EAAE,EAAE,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,CAAC;YAC9E,KAAK,EAAE,CAAC,EAAuB,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC;YAC/D,SAAS,EAAE,CAAC,EAA2B,EAAE,EAAE,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,EAAE,CAAC;SAC5E,CAAA;QAED,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,cAAc,EAAE,UAAU,CAAC,CAAA;QAC9D,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;IACxD,CAAC;IAEO,cAAc,CAAE,MAAoB,EAAE,EAA2B;QACvE,MAAM,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;QACvD,IAAI,CAAC,EAAE;YACL,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,CAAA;SACvC;IACH,CAAC;IAEO,UAAU,CAAE,MAAoB,EAAE,EAAuB;QAC/D,MAAM,GAAG,GAAmB,MAAM,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,CAAA;QACzE,IAAI,GAAG,EAAE;YACP,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;gBAChB,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,CAAA;YACxC,CAAC,CAAC,CAAA;SACH;IACH,CAAC;CACF;AA1GD,gCA0GC","sourcesContent":["import { ILooseObject } from '../collections/collection'\nimport {\n  ContainedSimpleField,\n  ContainedFieldSet,\n  ContainedGroupField,\n  ContainedComponentField,\n  FieldsDispatch\n} from '../dictionary/contained'\nimport { FixDefinitions, MessageDefinition } from '../dictionary/definition'\n\nimport moment = require('moment')\nimport { IFieldDispatcher } from '../dictionary/contained/field-dispatcher'\nimport { TagType } from '../buffer/tag/tag-type'\n\nexport class JsonHelper {\n  dispatcher: FieldsDispatch = new FieldsDispatch()\n  constructor (public readonly definitions: FixDefinitions) {\n  }\n\n  private static patchSimple (object: ILooseObject, field: ContainedSimpleField) {\n    let name: string = field.definition.name\n    let v: any = object[name]\n    if (v == null) {\n      v = object[field.name]\n      if (v !== null) {\n        name = field.name\n      }\n    }\n    if (v == null) {\n      return\n    }\n    switch (field.definition.tagType) {\n      case TagType.RawData: {\n        object[name] = Buffer.from(v, 'utf8')\n        break\n      }\n\n      case TagType.UtcTimestamp:\n        const m = moment(v)\n        const d = m.toDate()\n        object[name] = d\n        break\n\n      case TagType.UtcDateOnly: {\n        const m = moment(v)\n        object[name] = m.toDate()\n        break\n      }\n\n      case TagType.UtcTimeOnly: {\n        const m = moment(v)\n        object[name] = m.toDate()\n        break\n      }\n\n      case TagType.LocalDate: {\n        const m = moment(v)\n        object[name] = m.toDate()\n        break\n      }\n\n      case TagType.Float: {\n        object[name] = parseFloat(v)\n        break\n      }\n\n      case TagType.Int:\n      case TagType.Length: {\n        object[name] = parseInt(v, 10)\n        break\n      }\n    }\n  }\n\n  public fromJson (fileName: string, msgType: string): ILooseObject {\n    const msg: ILooseObject = require(fileName)\n    const def: MessageDefinition = this.definitions.message.get(msgType)\n    if (!def) {\n      return msg\n    }\n    if (msg.Batch) {\n      msg.Batch.forEach((m: ILooseObject) => {\n        this.patchJsonFields(def, m)\n      })\n    } else {\n      this.patchJsonFields(def, msg)\n    }\n    return msg\n  }\n\n  public patchJsonFields (set: ContainedFieldSet, object: ILooseObject): void {\n    if (!object) {\n      return\n    }\n\n    const dispatcher: IFieldDispatcher = {\n      simple: (field: ContainedSimpleField) => JsonHelper.patchSimple(object, field),\n      group: (gf: ContainedGroupField) => this.patchGroup(object, gf),\n      component: (cf: ContainedComponentField) => this.patchComponent(object, cf)\n    }\n\n    this.dispatcher.dispatchFields(set.localAttribute, dispatcher)\n    this.dispatcher.dispatchFields(set.fields, dispatcher)\n  }\n\n  private patchComponent (object: ILooseObject, cf: ContainedComponentField) {\n    const c = object[cf.name] || object[cf.definition.name]\n    if (c) {\n      this.patchJsonFields(cf.definition, c)\n    }\n  }\n\n  private patchGroup (object: ILooseObject, gf: ContainedGroupField) {\n    const arr: ILooseObject[] = object[gf.definition.name] || object[gf.name]\n    if (arr) {\n      arr.forEach((o) => {\n        this.patchJsonFields(gf.definition, o)\n      })\n    }\n  }\n}\n"]}