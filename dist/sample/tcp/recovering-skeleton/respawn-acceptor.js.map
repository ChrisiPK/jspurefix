{"version":3,"file":"respawn-acceptor.js","sourceRoot":"","sources":["../../../../src/sample/tcp/recovering-skeleton/respawn-acceptor.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AACA,gDAA4D;AAC5D,uCAA6C;AAC7C,kDAA8C;AAGvC,IAAM,eAAe,GAArB,MAAM,eAAgB,SAAQ,qBAAS;IAG5C,YAAqD,MAAoB;QACvE,KAAK,CAAC,MAAM,CAAC,CAAA;QADsC,WAAM,GAAN,MAAM,CAAc;QAEvE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAA;IAC3D,CAAC;IAKM,KAAK;QACV,OAAO,IAAI,CAAC,OAAO,EAAE,CAAA;IACvB,CAAC;IAEY,OAAO,CAAE,WAAmB,CAAC;;YACxC,OAAO,IAAI,OAAO,CAAM,CAAO,OAAO,EAAE,MAAM,EAAE,EAAE;gBAChD,IAAI,SAAS,GAAG,CAAC,CAAA;gBACjB,OAAO,SAAS,IAAI,QAAQ,EAAE;oBAC5B,IAAI;wBACF,MAAM,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAA;wBACrD,MAAM,QAAQ,GAAG,gBAAgB,CAAC,OAAO,CAAsB,yBAAmB,CAAC,CAAA;wBACnF,MAAM,qBAAqB,GAAG,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;wBACtD,gBAAgB,CAAC,QAAQ,CAAC,uBAAuB,EAAE,EAAE,QAAQ,EAAE,qBAAqB,EAAE,CAAC,CAAA;wBACvF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6CAA6C,SAAS,EAAE,CAAC,CAAA;wBAC1E,MAAM,QAAQ,CAAC,KAAK,EAAE,CAAA;wBACtB,MAAK;qBACN;oBAAC,OAAO,CAAC,EAAE;wBACV,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,0CAA0C,SAAS,EAAE,CAAC,CAAA;qBACxE;oBACD,EAAE,SAAS,CAAA;iBACZ;gBACD,IAAI,SAAS,GAAG,CAAC,EAAE;oBACjB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,+BAA+B,SAAS,EAAE,CAAC,CAAA;oBAC5D,MAAM,CAAC,SAAS,CAAC,CAAA;iBAClB;qBAAM;oBACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,SAAS,EAAE,CAAC,CAAA;oBAC1C,OAAO,CAAC,SAAS,CAAC,CAAA;iBACnB;YACH,CAAC,CAAA,CAAC,CAAA;QACJ,CAAC;KAAA;CACF,CAAA;AAzCY,eAAe;IAD3B,IAAA,qBAAU,GAAE;IAIG,WAAA,IAAA,iBAAM,EAAC,cAAc,CAAC,CAAA;;GAHzB,eAAe,CAyC3B;AAzCY,0CAAe","sourcesContent":["import { IJsFixConfig, IJsFixLogger } from '../../../config'\nimport { TcpAcceptorListener } from '../../../transport/tcp'\nimport { inject, injectable } from 'tsyringe'\nimport { FixEntity } from '../../../transport'\n\n@injectable()\nexport class RespawnAcceptor extends FixEntity {\n  private readonly logger: IJsFixLogger\n\n  constructor (@inject('IJsFixConfig') public readonly config: IJsFixConfig) {\n    super(config)\n    this.logger = config.logFactory.logger('RespawnAcceptor')\n  }\n\n  // if acceptor errors e.g. via a forced connection drop, then respawn\n  // a set number of times.\n\n  public start (): Promise<any> {\n    return this.waitFor()\n  }\n\n  public async waitFor (respawns: number = 1): Promise<any> {\n    return new Promise<any>(async (resolve, reject) => {\n      let respawned = 0\n      while (respawned <= respawns) {\n        try {\n          const sessionContainer = this.config.sessionContainer\n          const listener = sessionContainer.resolve<TcpAcceptorListener>(TcpAcceptorListener)\n          const dropConnectionTimeout = respawned === 0 ? 5 : -1\n          sessionContainer.register('dropConnectionTimeout', { useValue: dropConnectionTimeout })\n          this.logger.info(`waitFor: waiting for acceptor respawned = ${respawned}`)\n          await listener.start()\n          break\n        } catch (e) {\n          this.logger.info(`waitFor: error in acceptor respawned = ${respawned}`)\n        }\n        ++respawned\n      }\n      if (respawned > 0) {\n        this.logger.info(`acceptor respawned reject = ${respawned}`)\n        reject(respawned)\n      } else {\n        this.logger.info(`resolve = ${respawned}`)\n        resolve(respawned)\n      }\n    })\n  }\n}\n"]}