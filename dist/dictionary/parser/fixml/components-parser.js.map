{"version":3,"file":"components-parser.js","sourceRoot":"","sources":["../../../../src/dictionary/parser/fixml/components-parser.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { Dictionary } from '../../../collections'\nimport { XsdParser } from './xsd-parser'\nimport { ComponentFieldDefinition, SimpleFieldDefinition,\n  GroupFieldDefinition, FixDefinitions, MessageDefinition } from '../../definition'\nimport { ContainedSimpleField, ContainedComponentField,\n  ContainedFieldSet, ContainedGroupField } from '../../contained'\nimport { ISaxNode } from '../../sax-node'\n\ninterface IElement {\n  ref: string\n  name: string\n  type: string\n  minOccurs: string\n  maxOccurs: string\n  substitutionGroup: string\n}\n\ninterface IAttribute {\n  name: string\n  type: string\n  use: string\n}\n\ninterface IAttributeGroup {\n  name: string\n  attributes: IAttribute[]\n}\n\ninterface IGroup {\n  name: string\n  elements: IElement[]\n}\n\ninterface IAppInfo {\n  Protocol: string\n  MsgID: string\n  name: string,\n  ComponentType: string\n  Category: string\n}\n\n/*\n      <xs:complexContent>\n         <xs:extension base=\"BaseHeader_t\">\n            <xs:sequence>\n               <xs:group ref=\"BatchHeaderElements\"/>\n            </xs:sequence>\n            <xs:attributeGroup ref=\"BatchHeaderAttributes\"/>\n         </xs:extension>\n      </xs:complexContent>\n */\n\ninterface IAnnotation {\n  documentation: string\n}\n\ninterface IComplexType {\n  annotation: IAnnotation\n  extensionBase: string // where a reference to base class\n  element: IElement[]\n  messageName: string\n  name: string\n  appInfo: IAppInfo\n  group: string\n  attributeGroup: string\n}\n\nexport class ComponentsParser extends XsdParser {\n  private readonly attributeGroups: Dictionary<IAttributeGroup> = new Dictionary<IAttributeGroup>()\n  private readonly groups: Dictionary<IGroup> = new Dictionary<IGroup>()\n  private readonly unboundElements: IElement[] = []\n  private readonly complexTypes: Dictionary<IComplexType> = new Dictionary<IComplexType>()\n\n  private newComplexTypes: IComplexType[]\n  private currentGroup: IGroup\n  private currentAttributeGroupStack: IAttributeGroup[] = []\n  private currentComplexType: IComplexType\n  private previousComplexType: IComplexType\n\n  public constructor (public readonly definitions: FixDefinitions) {\n    super(definitions)\n  }\n\n  private static getName (group: IGroup, attributeGroup: IAttributeGroup, type: IComplexType): string {\n    let name: string\n    if (type && type.appInfo) {\n      name = type.appInfo.name\n    } else if (group) {\n      name = group.name\n    } else if (attributeGroup) {\n      name = attributeGroup.name\n    } else {\n      name = type.name\n    }\n    return name\n  }\n\n  public value (line: number, n: string, v: string): void {\n    // do nothing\n    switch (n) {\n      case 'xs:documentation': {\n        if (this.currentComplexType && this.currentComplexType.annotation) {\n          this.currentComplexType.annotation.documentation = v\n        }\n        break\n      }\n    }\n    this.pending = null\n  }\n\n  public close (line: number, node: string): void {\n    switch (node) {\n      case'xs:complexType': {\n        if (this.currentComplexType != null) {\n          const complex: IComplexType = this.currentComplexType\n          this.previousComplexType = complex\n          this.complexTypes.addUpdate(complex.name, complex)\n          this.newComplexTypes.push(complex)\n          this.currentComplexType = null\n        }\n        break\n      }\n\n      case 'xs:group': {\n        if (this.currentGroup) {\n          this.groups.addUpdate(this.currentGroup.name, this.currentGroup)\n          this.currentGroup = null\n        }\n        break\n      }\n\n      case 'xs:attributeGroup': {\n        const attributeStack = this.currentAttributeGroupStack\n        if (attributeStack.length > 0) {\n          const group: IAttributeGroup = attributeStack.pop()\n          this.attributeGroups.addUpdate(group.name, group)\n        }\n        break\n      }\n\n      case 'xs:schema': {\n        this.insertFields()\n        break\n      }\n    }\n  }\n\n  public open (line: number, node: ISaxNode): void {\n    switch (node.name) {\n\n      case 'xs:schema': {\n        this.newComplexTypes = []\n        break\n      }\n\n      case 'xs:group': {\n        this.xsGroup(node)\n        break\n      }\n\n      case 'xs:attributeGroup': {\n        this.xsAttributeGroup(node)\n        break\n      }\n\n      case 'xs:element': {\n        this.xsElement(node)\n        break\n      }\n\n      case 'xs:appinfo': {\n        this.currentComplexType.appInfo = {\n        } as IAppInfo\n        break\n      }\n\n      case 'xs:attribute': {\n        this.xsAttribute(node)\n        break\n      }\n\n      case 'xs:complexType': {\n        const unbound = this.unboundElements\n        this.currentComplexType = {\n          name: node.attributes.name || unbound[unbound.length - 1].name\n        } as IComplexType\n        break\n      }\n\n      case 'xs:extension': {\n        const current = this.currentComplexType\n        if (current && node.attributes.base) {\n          current.extensionBase = node.attributes.base\n        }\n        break\n      }\n\n      case 'fm:Xref': {\n        this.assign(node, this.currentComplexType.appInfo)\n        break\n      }\n\n      case 'xs:annotation': {\n        if (this.currentComplexType) {\n          this.currentComplexType.annotation = {} as IAnnotation\n        }\n        break\n      }\n\n      case 'xs:documentation': {\n        if (this.currentComplexType) {\n          this.pending = node.name\n        }\n        break\n      }\n    }\n  }\n\n  private xsAttribute (node: ISaxNode) {\n    const attribute: IAttribute = {} as IAttribute\n    this.assign(node, attribute)\n    const stack = this.currentAttributeGroupStack\n    if (stack.length > 0) {\n      const peek = stack[stack.length - 1]\n      const groupAttributes: IAttribute[] = peek.attributes\n      groupAttributes[groupAttributes.length] = attribute\n    }\n  }\n\n  private xsGroup (node: ISaxNode) {\n    if (node.attributes.name) {\n      this.currentGroup = {\n        name: node.attributes['name'],\n        elements: [] as IElement[]\n      } as IGroup\n    } else if (node.attributes.ref) {\n      if (this.currentComplexType) {\n        this.currentComplexType.group = node.attributes.ref\n      } else if (this.currentGroup) {\n        // this is part of a sequence for a group\n        const elements = this.currentGroup.elements\n        elements[elements.length] = {\n          type: node.name,\n          name: node.attributes.ref\n        } as IElement\n      }\n    }\n  }\n\n  private xsAttributeGroup (node: ISaxNode) {\n    const attributeStack = this.currentAttributeGroupStack\n    if (node.attributes.name) {\n      attributeStack.push({\n        name: node.attributes.name,\n        attributes: [] as IAttribute[]\n      } as IAttributeGroup)\n    } else if (node.attributes.ref) {\n      if (this.currentComplexType) {\n        this.currentComplexType.attributeGroup = node.attributes.ref\n      } else if (attributeStack.length > 0) {\n        const peek: IAttributeGroup = attributeStack[attributeStack.length - 1]\n        peek.attributes[peek.attributes.length] = {\n          type: node.name,\n          name: node.attributes.ref\n        } as IAttribute\n      }\n    }\n  }\n\n  private xsElement (node: ISaxNode) {\n    const element: IElement = {} as IElement\n    this.assign(node, element)\n    const currentComplex = this.currentComplexType\n    const currentGroup = this.currentGroup\n    if (!currentGroup && currentComplex) {\n      if (!currentComplex.element) {\n        currentComplex.element = []\n      }\n      const elements: IElement[] = currentComplex.element\n      elements[elements.length] = element\n    } else if (currentGroup) {\n      const elements = currentGroup.elements\n      elements[elements.length] = element\n    } else {\n      if (element.substitutionGroup && this.previousComplexType) {\n        this.previousComplexType.messageName = element.name\n      } else {\n        this.unboundElements.push(element)\n      }\n    }\n  }\n\n  private addElement (set: ContainedFieldSet, element: IElement) {\n    const minOccurs: number = parseInt(element.minOccurs, 10)\n    const isGroup: boolean = element.maxOccurs === 'unbounded'\n    const isComponent: boolean = element.maxOccurs === '1' || !isGroup\n    const key = element.type || element.ref || element.name\n    const containedType: IComplexType = this.complexTypes.get(key)\n    if (containedType) {\n      if (isComponent) {\n        const containedDefinition: ComponentFieldDefinition = this.getComponent(containedType)\n        const containedField: ContainedComponentField =\n          new ContainedComponentField(containedDefinition,\n            set.fields.length,\n            minOccurs > 0,\n            element.name)\n        set.add(containedField)\n      } else if (isGroup) {\n        const containedDefinition: GroupFieldDefinition = this.getGroup(containedType)\n        const containedField: ContainedGroupField =\n          new ContainedGroupField(containedDefinition,\n            set.fields.length,\n            minOccurs > 0,\n            element.name)\n        set.add(containedField)\n      }\n    } else {\n      if (key !== 'Message') {\n        throw new Error(`cannot resolve component ${key} contained in ${set.name}`)\n      }\n    }\n  }\n\n  private addElements (set: ContainedFieldSet, elements: IElement[]) {\n    if (elements) {\n      elements.forEach((element: IElement) => {\n        switch (element.type) {\n          case 'xs:group':\n            const groupElements: IGroup = this.groups.get(element.name)\n            if (groupElements) {\n              this.addElements(set, groupElements.elements)\n            } else {\n              throw new Error(`unable to get xs:group ${element.name}`)\n            }\n            break\n\n          default: {\n            this.addElement(set, element)\n          }\n        }\n      })\n    }\n  }\n\n  private addSimpleAttribute (set: ContainedFieldSet, attribute: IAttribute): void {\n    let sf: SimpleFieldDefinition = this.definitions.getSimple(attribute.type)\n    if (!sf) {\n      sf = this.definitions.getSimple(attribute.name, set.category)\n    }\n    if (sf) {\n      const contained: ContainedSimpleField = new ContainedSimpleField(sf,\n        set.fields.length,\n        attribute.use !== 'optional',\n        true,\n        attribute.name)\n      set.add(contained)\n    } else if (set.name !== 'FixmlAttributes') {\n      throw new Error(`unable to resolve simple attribute ${attribute.name}`)\n    }\n  }\n\n  private addAttributes (set: ContainedFieldSet, attributes: IAttribute[]) {\n\n    attributes.forEach((attribute: IAttribute) => {\n      switch (attribute.type) {\n        case 'xs:attributeGroup': {\n          const attributeGroup: IAttributeGroup = this.attributeGroups.get(attribute.name)\n          if (attributeGroup) {\n            this.addAttributes(set, attributeGroup.attributes)\n          } else {\n            throw new Error(`unable to get xs:attributeGroup ${attribute.name}`)\n          }\n          break\n        }\n\n        default: {\n          this.addSimpleAttribute(set, attribute)\n        }\n      }\n    })\n  }\n\n  private getGroup (type: IComplexType): GroupFieldDefinition {\n    let group: IGroup = this.groups.get(type.group)\n    const attributeGroup: IAttributeGroup = this.attributeGroups.get(type.attributeGroup)\n    const name: string = ComponentsParser.getName(group, attributeGroup, type)\n    const category: string = type.appInfo != null ? type.appInfo.Category : null\n    const groupDefinition: GroupFieldDefinition = new GroupFieldDefinition(name, name, category, null, null)\n    this.populateSet(type, groupDefinition)\n    return groupDefinition\n  }\n\n  private getComponent (type: IComplexType): ComponentFieldDefinition {\n    const definitions = this.definitions\n    let group: IGroup = this.groups.get(type.group)\n    const attributeGroup: IAttributeGroup = this.attributeGroups.get(type.attributeGroup)\n    let name: string = ComponentsParser.getName(group, attributeGroup, type)\n    const cached: ComponentFieldDefinition = definitions.component.get(name)\n    if (cached) {\n      return cached\n    }\n\n    const category: string = type.appInfo != null ? type.appInfo.Category : null\n    if (type.extensionBase) {\n      let base = this.complexTypes.get(type.extensionBase)\n      if (base) {\n        name = base.appInfo.name\n      }\n    }\n    const component: ComponentFieldDefinition = new ComponentFieldDefinition(name, name, category, null)\n    this.populateSet(type, component)\n    definitions.component.addUpdate(component.name, component)\n    definitions.component.addUpdate(type.name, component)\n    return component\n  }\n\n  private getMessage (type: IComplexType): MessageDefinition {\n    const definitions = this.definitions\n    const messages = definitions.message\n    const name: string = type.appInfo.name\n    const message: MessageDefinition = new MessageDefinition(name,\n      type.messageName,\n      type.appInfo.MsgID,\n      type.appInfo.Category,\n      type.annotation.documentation)\n    const abstractMessage: ComponentFieldDefinition = definitions.component.get('Message')\n    abstractMessage.fields.forEach((f) => {\n      message.add(f)\n    })\n    this.populateSet(type, message)\n    messages.addUpdate(message.name, message)\n    if (type.messageName && type.messageName !== name) {\n      messages.addUpdate(type.messageName, message)\n    }\n\n    return message\n  }\n\n  private getBaseAttributes (type: IComplexType): IAttributeGroup {\n    const attributeGroups = this.attributeGroups\n    let baseGroup: IAttributeGroup = null\n    if (type.extensionBase) {\n      let base = this.complexTypes.get(type.extensionBase)\n      if (base) {\n        baseGroup = attributeGroups.get(base.attributeGroup)\n      }\n      return baseGroup\n    }\n    return null\n  }\n\n  private populateSet (type: IComplexType, set: ContainedFieldSet): void {\n    const group: IGroup = this.groups.get(type.group)\n    const elements: IElement[] = group ? group.elements : type.element\n    const attributeGroups = this.attributeGroups\n    const attributeGroup: IAttributeGroup = attributeGroups.get(type.attributeGroup)\n    const baseGroup: IAttributeGroup = this.getBaseAttributes(type)\n    // if a base is specified add the attributes from there\n    if (baseGroup) {\n      this.addAttributes(set, baseGroup.attributes)\n    }\n    if (attributeGroup) {\n      this.addAttributes(set, attributeGroup.attributes)\n    }\n    this.addElements(set, elements)\n  }\n\n  private constructType (type: IComplexType) {\n    const componentType: string = type.appInfo != null ? type.appInfo.ComponentType : 'Block'\n    switch (componentType) {\n\n      case 'Message': {\n        const message: MessageDefinition = this.getMessage(type)\n        if (!message) {\n          throw new Error(`cannot resolve ${type.name}`)\n        }\n        break\n      }\n\n      // these may be included from top level messages and added into definitions\n      case 'Block': {\n        const component: ComponentFieldDefinition = this.getComponent(type)\n        if (!component) {\n          throw new Error(`cannot resolve ${type.name}`)\n        }\n        break\n      }\n\n      case 'ImplicitBlock':\n      case 'XMLDataBlock':\n      case 'BlockRepeating':\n      case 'ImplicitBlockRepeating': {\n        break\n      }\n\n      default:\n        throw new Error(`unknown type ${componentType}`)\n    }\n  }\n\n  private insertFields (): void {\n    this.newComplexTypes.forEach((type: IComplexType) => {\n      this.constructType(type)\n    })\n    this.unboundElements.forEach((e: IElement) => {\n      const definitions = this.definitions\n      const component = definitions.component.get(e.type)\n      if (component) {\n        definitions.component.addUpdate(e.name, component)\n      }\n    })\n  }\n}\n"]}