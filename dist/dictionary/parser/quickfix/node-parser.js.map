{"version":3,"file":"node-parser.js","sourceRoot":"","sources":["../../../../src/dictionary/parser/quickfix/node-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContainedGroupField, ContainedSimpleField, ContainedComponentField } from '../../contained'\nimport { FixDefinitions, GroupFieldDefinition, SimpleFieldDefinition, ComponentFieldDefinition } from '../../definition'\nimport { ParseContext } from './parse-context'\nimport { ISaxNode } from '../../sax-node'\n\nexport abstract class NodeParser {\n  protected readonly parseContexts: ParseContext[] = []\n\n  protected constructor (public readonly definitions: FixDefinitions, public passes: number) {\n  }\n\n  public abstract open (line: number, node: ISaxNode): void\n\n  public abstract close (line: number, node: string): void\n\n  protected addSimple (node: ISaxNode): void {\n    if (node.isSelfClosing) {\n      const parent: ParseContext = this.peek()\n      if (parent == null) {\n        throw new Error(`simple field ${node.name} has no parent on which to add.`)\n      }\n      const fieldName: string = node.attributes.name\n      const fieldDefinition: SimpleFieldDefinition = this.definitions.simple.get(fieldName)\n      if (fieldDefinition == null) {\n        throw new Error(`simple field ${fieldName} has no declaration in dictionary.`)\n      }\n      const containedField: ContainedSimpleField = new ContainedSimpleField(fieldDefinition,\n                parent.set.fields.length, node.attributes.required === 'Y', false)\n      parent.set.add(containedField)\n    }\n  }\n\n  protected addComponentField (componentName: string, node: ISaxNode): void {\n    const parent: ParseContext = this.peek()\n    if (parent == null) {\n      throw new Error(`component ${node.name} has no parent on which to add.`)\n    }\n    const fieldDef: ComponentFieldDefinition = this.definitions.component.get(componentName)\n    if (fieldDef != null) {\n      const containedField: ContainedComponentField =\n                new ContainedComponentField(fieldDef, parent.set.fields.length, parent.required)\n      parent.set.add(containedField)\n    } else {\n      if (this.passes >= 4) {\n        throw new Error(`field ${node.name} includes unknown component ${componentName}.`)\n      }\n    }\n  }\n\n  protected addGroupField (name: string): void {\n    const group: ParseContext = this.parseContexts.pop()\n    if (group == null) {\n      throw new Error(`group field ${name} closes yet does not exist.`)\n    }\n    const parent: ParseContext = this.peek()\n    if (parent != null) {\n      const asGroup: GroupFieldDefinition = group.asGroup()\n      const containedField: ContainedGroupField =\n                new ContainedGroupField(asGroup, parent.set.fields.length, group.required)\n      parent.set.add(containedField)\n    } else {\n      throw new Error(`group field ${group.name} has no parent on which to add.`)\n    }\n  }\n\n  protected beginGroupDefinition (node: ISaxNode): void {\n    if (!node.isSelfClosing) {\n            // a group should have a field that matches its name\n      const groupName: string = node.attributes.name\n      const noOfField: SimpleFieldDefinition = this.definitions.simple.get(groupName)\n      if (noOfField == null) {\n        const msg: string = `group ${groupName} has no field defined.`\n        throw new Error(msg)\n      }\n      const set: GroupFieldDefinition = new GroupFieldDefinition(groupName, groupName, null, noOfField,null)\n      const context: ParseContext = new ParseContext(node.attributes.name, true, set)\n      context.required = node.attributes.required === 'Y'\n      this.parseContexts.push(context)\n    }\n  }\n\n  private peek (): ParseContext {\n    return this.parseContexts.length > 0 ? this.parseContexts[this.parseContexts.length - 1] : null\n  }\n}\n"]}