{"version":3,"file":"fix-msg-ascii-store-resend.js","sourceRoot":"","sources":["../../src/store/fix-msg-ascii-store-resend.ts"],"names":[],"mappings":"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","sourcesContent":["import { IFixMsgStore } from './fix-msg-store'\nimport { FixMsgStoreRecord, IFixMsgStoreRecord } from './fix-msg-store-record'\nimport { IJsFixConfig } from '../config'\nimport { MsgType } from '../types'\nimport { ElasticBuffer, MsgView } from '../buffer'\nimport { AsciiParser } from '../buffer/ascii'\nimport { ISequenceReset, IStandardHeader } from '../types/FIX4.4/repo'\n\nexport class FixMsgAsciiStoreResend {\n  parser: AsciiParser\n  constructor (public readonly store: IFixMsgStore, public readonly config: IJsFixConfig) {\n    this.parser = new AsciiParser(this.config, null, new ElasticBuffer(160 * 1024))\n  }\n\n  public getResendRequest (startSeq: number, endSeq: number): Promise<IFixMsgStoreRecord[]> {\n\n    // need to cover request from start to end where any missing numbers are\n    // included as gaps to allow vector of messages to be sent by the session\n    // on a request\n\n    return new Promise((resolve, reject) => {\n      this.store.getSeqNumRange(startSeq, endSeq).then(res => {\n        resolve(this.inflateRange(startSeq, endSeq, res))\n      }).catch(e => {\n        reject(e)\n      })\n    })\n  }\n\n  private inflateRange (startSeq: number, endSeq: number, input: IFixMsgStoreRecord[]): IFixMsgStoreRecord[] {\n    const toResend: IFixMsgStoreRecord[] = []\n    let expected = startSeq\n    for (let i = 0; i < input.length; ++i) {\n      const record = input[i].clone()\n      const seqNum = record.seqNum\n      const toGap = seqNum - expected\n      if (toGap > 0) {\n        this.gap(expected, seqNum, toResend)\n      }\n      expected = seqNum + 1\n      if (record.encoded) {\n        this.inflate(record)\n      }\n      toResend.push(record)\n    }\n    if (endSeq - expected > 0) {\n      this.gap(expected, endSeq + 1, toResend)\n    }\n    return toResend\n  }\n\n  public gap (beginGap: number, seqNum: number, arr: IFixMsgStoreRecord[]) {\n    if (beginGap > 0) {\n      arr.push(this.sequenceResetGap(beginGap, seqNum))\n    }\n  }\n\n  // if records were sent as encoded text then inflate back to object\n  // so can be resent or examined\n\n  public inflate (record: IFixMsgStoreRecord): void {\n    if (record.obj) return\n    if (!record.encoded) return\n    const parser = this.parser\n    parser.on('error', (e: Error) => {\n      record.obj = null\n    })\n    parser.on('msg', (view: MsgView) => {\n      record.obj = view.toObject()\n    })\n    // inline parse\n    parser.parseText(record.encoded)\n  }\n\n  public sequenceResetGap (startGap: number, newSeq: number): IFixMsgStoreRecord {\n    const factory = this.config.factory\n    const gapFill: ISequenceReset = factory.sequenceReset(newSeq, true) as ISequenceReset\n    gapFill.StandardHeader = factory.header(MsgType.SequenceReset, startGap) as IStandardHeader\n    gapFill.StandardHeader.PossDupFlag = true\n    gapFill.NewSeqNo = newSeq\n    return new FixMsgStoreRecord(\n      MsgType.SequenceReset,\n      new Date(),\n      newSeq,\n      gapFill,\n      null)\n  }\n}\n"]}