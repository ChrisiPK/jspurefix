{"version":3,"file":"msg-view.js","sourceRoot":"","sources":["../../src/buffer/msg-view.ts"],"names":[],"mappings":";;;AAAA,2CAAsC;AAOtC,8CAAyC;AAEzC,qDAAgD;AAGhD,yEAAmE;AAEnE,MAAsB,OAAO;IAI3B,YAAuC,OAA2B,EAAkB,SAAoB;QAAjE,YAAO,GAAP,OAAO,CAAoB;QAAkB,cAAS,GAAT,SAAS,CAAW;IACxG,CAAC;IAES,MAAM,CAAC,SAAS,CAAE,KAA4B,EAAE,GAAW,EAAE,CAAS,EAAE,KAAa,EAAE,EAAU;QACzG,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAA;QACjC,IAAI,IAAY,CAAA;QAChB,IAAI,IAAY,CAAA;QAChB,IAAI,KAAK,EAAE;YACT,IAAI,GAAG,KAAK,CAAC,IAAI,IAAI,SAAS,CAAA;YAC9B,IAAI,KAAK,CAAC,MAAM,EAAE,EAAE;gBAClB,IAAI,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,OAAO,KAAK,KAAK,CAAC,WAAW,IAAI,EAAE,GAAG,OAAO,GAAG,OAAO,EAAE,CAAA;aACrG;iBAAM;gBACL,IAAI,GAAG,GAAG,GAAG,GAAG,OAAO,IAAI,KAAK,CAAC,WAAW,IAAI,EAAE,GAAG,OAAO,GAAG,OAAO,EAAE,CAAA;aACzE;SACF;aAAM;YACL,IAAI,GAAG,SAAS,CAAA;SACjB;QACD,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,IAAI,OAAO,IAAI,EAAE,CAAA;IAC/C,CAAC;IAES,MAAM,CAAC,OAAO,CAAE,KAA4B,EAAE,GAAW,EAAE,CAAS,EAAE,KAAa,EAAE,EAAU;QACvG,MAAM,OAAO,GAAW,CAAC,CAAA;QACzB,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAA;QAEjC,IAAI,IAAY,CAAA;QAChB,IAAI,IAAY,CAAA;QAChB,IAAI,KAAK,EAAE;YACT,IAAI,GAAG,KAAK,CAAC,IAAI,IAAI,SAAS,CAAA;YAC9B,IAAI,KAAK,CAAC,MAAM,EAAE,EAAE;gBAClB,IAAI,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAA;aAC3C;iBAAM;gBACL,IAAI,GAAG,GAAG,GAAG,EAAE,CAAA;aAChB;SACF;aAAM;YACL,IAAI,GAAG,GAAG,GAAG,EAAE,CAAA;YACf,IAAI,GAAG,SAAS,CAAA;SACjB;QACD,IAAI,SAAiB,CAAA;QACrB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YACnD,SAAS,GAAG,OAAO,CAAA;SACpB;aAAM;YACL,SAAS,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAA;SAClC;QACD,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,IAAI,OAAO,IAAI,GAAG,SAAS,EAAE,CAAA;IAC3D,CAAC;IAGM,OAAO;QACZ,MAAM,WAAW,GAAa,EAAE,CAAA;QAChC,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAA;QAC5B,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAA;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,EAAE,EAAE,CAAC,EAAE;YACxC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAA;YAC9B,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;gBACtC,WAAW,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,GAAG,CAAA;aACtC;SACF;QACD,OAAO,WAAW,CAAA;IACpB,CAAC;IAGM,OAAO;QACZ,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAA;IACnD,CAAC;IAEM,QAAQ,CAAE,SAA0B;QACzC,MAAM,GAAG,GAAW,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAA;QAC9C,MAAM,QAAQ,GAAW,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;QAC9C,OAAO,QAAQ,IAAI,CAAC,CAAA;IACtB,CAAC;IAEM,gBAAgB,CAAE,CAAS;QAChC,MAAM,QAAQ,GAAuB,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAA;QAChE,IAAI,CAAC,QAAQ,EAAE;YACb,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;IAC9B,CAAC;IAEM,YAAY;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;IAC5C,CAAC;IAEM,eAAe;QACpB,IAAI,GAAG,GAAW,IAAI,CAAA;QACtB,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,EAAE,CAAA;QACzC,IAAI,aAAa,EAAE;YACjB,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;gBAChC,GAAG,GAAG,mBAAmB,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,CAAqB,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;aAC3G;iBAAM;gBACL,GAAG,GAAG,mBAAmB,aAAa,CAAC,QAAQ,EAAE,CAAA;aAClD;SACF;QACD,OAAO,GAAG,CAAA;IACZ,CAAC;IAEM,UAAU;QACf,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAA;QACjD,OAAO,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;IACzC,CAAC;IAEM,SAAS,CAAE,SAA0B;QAC1C,MAAM,GAAG,GAAW,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAA;QAC9C,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,OAAO,IAAI,CAAA;SACZ;QACD,MAAM,QAAQ,GAAW,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;QAC9C,IAAI,QAAQ,GAAG,CAAC,EAAE;YAChB,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAA;IACxC,CAAC;IAEM,UAAU,CAAE,YAA6B,CAAC,CAAC;QAChD,IAAI,SAAS,GAAG,CAAC,EAAE;YACjB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAA;SACzB;QACD,MAAM,GAAG,GAAW,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAA;QAC9C,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,OAAO,IAAI,CAAA;SACZ;QACD,MAAM,SAAS,GAAa,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAA;QAClD,IAAI,SAAS,IAAI,IAAI,EAAE;YACrB,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,QAAgB,EAAE,EAAE;YACxC,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAA;QACxC,CAAC,CAAC,CAAA;IACJ,CAAC;IAEM,QAAQ,CAAE,SAA0B;QACzC,MAAM,GAAG,GAAW,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAA;QAC9C,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,OAAO,IAAI,CAAA;SACZ;QACD,MAAM,KAAK,GAA0B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;QACrF,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;IAC5B,CAAC;IAEM,YAAY,CAAE,SAAgB;QACnC,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;IAC/C,CAAC;IAEM,QAAQ;QACb,MAAM,OAAO,GAAuB,IAAI,CAAC,OAAO,CAAA;QAChD,IAAI,OAAO,CAAC,YAAY,EAAE;YACxB,QAAQ,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE;gBACxB,KAAK,qCAAgB,CAAC,KAAK,CAAC,CAAC;oBAC3B,OAAO,IAAI,CAAC,WAAW,CAAE,OAAO,CAAC,GAA4B,CAAC,IAAI,CAAC,CAAA;iBACpE;gBACD,KAAK,qCAAgB,CAAC,GAAG,CAAC,CAAC;oBAEzB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;oBACnC,MAAM,KAAK,GAAiB,EAAE,CAAA;oBAC9B,IAAI,OAAO,EAAE;wBACX,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAA;qBACrD;oBACD,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;oBACpD,OAAO,KAAK,CAAA;iBACb;aACF;SACF;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;IAClC,CAAC;IAEM,QAAQ;QACb,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;IACxC,CAAC;IAEM,SAAS;QACd,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,SAAS,CAAC,CAAA;IAC1C,CAAC;IAEM,MAAM;QACX,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;IACjD,CAAC;IAEM,OAAO,CAAE,IAAY;QAC1B,MAAM,KAAK,GAAa,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QACvC,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,CAAU,EAAE,OAAe,EAAE,EAAE;YAClD,IAAI,CAAC,CAAC,EAAE;gBACN,OAAO,CAAC,CAAA;aACT;YACD,MAAM,SAAS,GAAG,CAAC,CAAC,SAAS,CAAA;YAC7B,MAAM,SAAS,GAAuB,SAAS,CAAC,oBAAoB,CAAC,OAAO,EAAE,CAAC,CAAC,OAAO,CAAC,CAAA;YACxF,IAAI,SAAS,EAAE;gBACb,OAAO,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;aAC3B;YAED,MAAM,SAAS,GAAmB,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAA;YAC7E,IAAI,SAAS,EAAE;gBACb,MAAM,WAAW,GAAuB,SAAS,CAAC,oBAAoB,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAA;gBACjG,IAAI,WAAW,EAAE;oBACf,OAAO,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;iBAC7B;aACF;YACD,OAAO,IAAI,CAAA;QACb,CAAC,EAAE,IAAe,CAAC,CAAA;IACrB,CAAC;IAYS,UAAU,CAAE,SAA0B;QAC9C,IAAI,GAAW,CAAA;QACf,IAAI,OAAM,CAAC,SAAS,CAAC,KAAK,QAAQ,EAAE;YAClC,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;YAC/C,MAAM,CAAC,GAA0B,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;YAC3G,IAAI,CAAC,IAAI,IAAI,EAAE;gBACb,OAAO,IAAI,CAAA;aACZ;YACD,GAAG,GAAG,CAAC,CAAC,GAAG,CAAA;SACZ;aAAM;YACL,GAAG,GAAG,SAAS,CAAA;SAChB;QACD,OAAO,GAAG,CAAA;IACZ,CAAC;IAGS,YAAY,CAAE,GAAW;QACjC,MAAM,QAAQ,GAAa,IAAI,CAAC,oBAAoB,CAAA;QACpD,MAAM,SAAS,GAAa,IAAI,CAAC,qBAAqB,CAAA;QACtD,MAAM,QAAQ,GAAW,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAA;QAC/C,IAAI,QAAQ,GAAG,CAAC,EAAE;YAChB,OAAO,IAAI,CAAA;SACZ;QAED,MAAM,KAAK,GAAW,QAAQ,CAAC,MAAM,CAAA;QACrC,MAAM,IAAI,GAAW,KAAK,GAAG,CAAC,CAAA;QAC9B,IAAI,GAAG,GAAW,QAAQ,CAAA;QAC1B,OAAO,GAAG,IAAI,IAAI,EAAE;YAClB,IAAI,GAAG,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;gBAC7B,MAAK;aACN;YACD,EAAE,GAAG,CAAA;SACN;QAED,IAAI,KAAK,GAAW,IAAI,GAAG,QAAQ,CAAA;QACnC,OAAO,KAAK,IAAI,IAAI,EAAE;YACpB,IAAI,GAAG,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE;gBAChC,MAAK;aACN;YACD,EAAE,KAAK,CAAA;SACR;QACD,MAAM,KAAK,GAAW,IAAI,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;QACxC,MAAM,GAAG,GAAW,GAAG,GAAG,KAAK,CAAA;QAC/B,MAAM,SAAS,GAAa,IAAI,KAAK,CAAC,GAAG,CAAC,CAAA;QAC1C,KAAK,IAAI,CAAC,GAAW,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;YACxC,SAAS,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAA;SAC5C;QACD,OAAO,SAAS,CAAA;IAClB,CAAC;IAES,WAAW,CAAE,GAAW;QAChC,MAAM,GAAG,GAAW,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAA;QAC1C,IAAI,GAAG,IAAI,CAAC,EAAE;YACZ,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAA;SAC/C;aAAM;YACL,OAAO,CAAC,CAAC,CAAA;SACV;IACH,CAAC;IAEO,UAAU;QAChB,MAAM,OAAO,GAAuB,IAAI,CAAC,OAAO,CAAA;QAChD,MAAM,KAAK,GAAa,EAAE,CAAA;QAC1B,KAAK,IAAI,CAAC,GAAW,OAAO,CAAC,aAAa,EAAE,CAAC,IAAI,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,EAAE;YACzE,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;SACxB;QACD,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,CAAS,EAAE,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAA;IAC3D,CAAC;IAEO,WAAW,CAAE,IAAY;QAC/B,MAAM,SAAS,GAAY,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;QAC7C,IAAI,SAAS,IAAI,IAAI,EAAE;YACrB,OAAM;SACP;QACD,MAAM,UAAU,GAAmB,IAAI,KAAK,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,CAAA;QACpE,MAAM,KAAK,GAAW,SAAS,CAAC,UAAU,EAAE,CAAA;QAC5C,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;YACtC,MAAM,QAAQ,GAAY,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAA;YACvD,UAAU,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAA;SACpC;QACD,OAAO,UAAU,CAAA;IACnB,CAAC;IAEO,OAAO,CAAE,GAAsB;QACrC,MAAM,OAAO,GAAG,IAAI,sBAAS,EAAgB,CAAA;QAC7C,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE;YACzB,KAAK,EAAE,CAAC,CAAe,EAAE,KAA0B,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,KAAK,CAAC;YACnF,MAAM,EAAE,CAAC,CAAe,EAAE,KAA2B,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,KAAK,CAAC;YACtF,SAAS,EAAE,CAAC,CAAe,EAAE,KAA8B,EAAE,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE,KAAK,CAAC;SAC/D,EAAE,GAAG,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAe,EAAE,EAAwB,EAAE,EAAE;YAC1G,MAAM,GAAG,GAAG,EAAE,CAAC,UAAU,CAAA;YACzB,MAAM,QAAQ,GAAW,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;YAClD,IAAI,QAAQ,IAAI,CAAC,EAAE;gBACjB,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;aAChC;YACD,OAAO,CAAC,CAAA;QACV,CAAC,EAAE,EAAkB,CAAC,CAAC,CAAA;IACzB,CAAC;IAEO,eAAe,CAAE,GAAsB,EAAE,IAAe;QAC9D,MAAM,OAAO,GAAG,IAAI,sBAAS,EAAY,CAAA;QACzC,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE;YACzB,KAAK,EAAE,CAAC,CAAW,EAAE,KAA0B,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC,CAAC;YACpF,MAAM,EAAE,CAAC,CAAW,EAAE,KAA2B,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;YAClF,SAAS,EAAE,CAAC,CAAW,EAAE,KAA8B,EAAE,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC,CAAC;SAC/D,EAAE,IAAI,CAAC,CAAA;IACvC,CAAC;IAEO,aAAa,CAAE,EAAwB,EAAE,CAAW;QAC1D,IAAI,EAAE,CAAC,QAAQ,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YAC1D,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;SAC1B;IACH,CAAC;IAEO,gBAAgB,CAAE,EAA2B,EAAE,CAAW;QAChE,MAAM,IAAI,GAAY,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,CAAA;QAC3C,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,CAAA;SACvC;IACH,CAAC;IAEO,YAAY,CAAE,GAAsB,EAAE,EAAuB,EAAE,IAAe;QACpF,MAAM,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAA;QAC9E,MAAM,SAAS,GAAY,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;QACjF,IAAI,SAAS,IAAI,IAAI,EAAE;YACrB,OAAM;SACP;QACD,MAAM,KAAK,GAAW,SAAS,CAAC,UAAU,EAAE,CAAA;QAC5C,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE;YACtC,MAAM,QAAQ,GAAY,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAA;YACvD,QAAQ,CAAC,eAAe,CAAC,EAAE,CAAC,UAAU,EAAE,IAAI,CAAC,CAAA;SAC9C;IACH,CAAC;IAEO,gBAAgB,CAAE,CAAe,EAAE,EAA2B;QACpE,MAAM,IAAI,GAAY,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,CAAA;QAC3C,IAAI,IAAI,EAAE;YACR,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAA;YACjC,IAAI,SAAS,EAAE;gBACb,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,CAAA;aAClC;SACF;IACH,CAAC;IAEO,aAAa,CAAE,CAAe,EAAE,EAAwB;QAC9D,MAAM,GAAG,GAAG,EAAE,CAAC,UAAU,CAAA;QACzB,MAAM,QAAQ,GAAW,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QAClD,IAAI,QAAQ,IAAI,CAAC,EAAE;YACjB,MAAM,QAAQ,GAAQ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;YACvC,IAAI,QAAQ,IAAI,IAAI,EAAE;gBACpB,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAA;aACtB;SACF;IACH,CAAC;IAEO,YAAY,CAAE,CAAe,EAAE,EAAuB;QAC5D,MAAM,GAAG,GAAG,EAAE,CAAC,UAAU,CAAA;QACzB,MAAM,IAAI,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAA;QAC1D,MAAM,SAAS,GAAiB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QACpF,IAAI,SAAS,EAAE;YACb,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,CAAA;SACxB;IACH,CAAC;IAEO,YAAY,CAAE,GAAW;QAC/B,IAAI,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAA;QACxC,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAA;YAC5B,QAAQ,GAAG,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,WAAW,GAAG,CAAC,CAAC,CAAA;YACvH,QAAQ,CAAC,IAAI,CAAC,gBAAM,CAAC,OAAO,CAAC,CAAA;YAC7B,IAAI,CAAC,qBAAqB,GAAG,QAAQ,CAAC,KAAK,EAAE,CAAC,OAAO,EAAE,CAAA;SACxD;QACD,OAAO,gBAAM,CAAC,YAAY,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAA;IAC3C,CAAC;IAEO,SAAS,CAAE,QAAqG;QACtH,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAA;QAChC,MAAM,MAAM,GAAkB,IAAI,8BAAa,EAAE,CAAA;QACjD,MAAM,OAAO,GAAuB,IAAI,CAAC,OAAO,CAAA;QAChD,MAAM,IAAI,GAAS,SAAS,CAAC,IAAI,CAAA;QACjC,MAAM,KAAK,GAAW,OAAO,CAAC,WAAW,GAAG,OAAO,CAAC,aAAa,CAAA;QACjE,MAAM,MAAM,GAAsC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAA;QAEzE,KAAK,IAAI,CAAC,GAAW,OAAO,CAAC,aAAa,EAAE,CAAC,IAAI,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,EAAE;YACzE,MAAM,MAAM,GAAW,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;YACrC,MAAM,KAAK,GAA0B,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAA;YACtE,MAAM,GAAG,GAAW,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAA;YAC5C,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC,aAAa,EAAE,KAAK,EAAE,MAAM,CAAC,CAAA;YAC5E,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;SAC1B;QAED,OAAO,MAAM,CAAC,QAAQ,EAAE,CAAA;IAC1B,CAAC;CACF;AAzZD,0BAyZC","sourcesContent":["import { TagPos } from './tag/tag-pos'\nimport { SegmentDescription } from './segment/segment-description'\nimport { Structure } from './structure'\nimport { Dictionary } from '../collections'\nimport { Tags } from './tag/tags'\nimport { ContainedGroupField, ContainedComponentField, ContainedField,\n  ContainedFieldSet, ContainedSimpleField } from '../dictionary/contained'\nimport { SetReduce } from '../dictionary'\nimport { ILooseObject } from '../collections/collection'\nimport { ElasticBuffer } from './elastic-buffer'\nimport { GroupFieldDefinition, SimpleFieldDefinition } from '../dictionary/definition'\nimport { ITypeDispatcher } from '../dictionary/type-dispatcher'\nimport { ContainedSetType } from '../dictionary/contained-set-type'\n\nexport abstract class MsgView {\n  protected sortedTagPosForwards: TagPos[]\n  protected sortedTagPosBackwards: TagPos[]\n\n  protected constructor (public readonly segment: SegmentDescription, public readonly structure: Structure) {\n  }\n\n  protected static asVerbose (field: SimpleFieldDefinition, val: string, i: number, count: number, tp: TagPos): string {\n    const newLine = require('os').EOL\n    let desc: string\n    let name: string\n    if (field) {\n      name = field.name || 'unknown'\n      if (field.isEnum()) {\n        desc = `${val}[${field.resolveEnum(val)}]${newLine}\\t${field.description || ''}${newLine}${newLine}`\n      } else {\n        desc = `${val}${newLine}t${field.description || ''}${newLine}${newLine}`\n      }\n    } else {\n      name = 'unknown'\n    }\n    return `[${i}] ${tp.tag} (${name}) = ${desc}`\n  }\n\n  protected static asToken (field: SimpleFieldDefinition, val: string, i: number, count: number, tp: TagPos): string {\n    const perLine: number = 2\n    const newLine = require('os').EOL\n    // [280] 814 (ApplQueueResolution) = 2[OverlayLast][281] 10 (CheckSum) = 80\n    let desc: string\n    let name: string\n    if (field) {\n      name = field.name || 'unknown'\n      if (field.isEnum()) {\n        desc = `${val}[${field.resolveEnum(val)}]`\n      } else {\n        desc = `${val}`\n      }\n    } else {\n      desc = `${val}`\n      name = 'unknown'\n    }\n    let delimiter: string\n    if (i === 1 || (i < count && i % perLine - 1 === 0)) {\n      delimiter = newLine\n    } else {\n      delimiter = i < count ? ', ' : ''\n    }\n    return `[${i}] ${tp.tag} (${name}) = ${desc}${delimiter}`\n  }\n\n  // return list of any tags parsed that are not valid\n  public invalid (): number[] {\n    const invalidTags: number[] = []\n    const set = this.segment.set\n    const tags = this.structure.tags\n    for (let i = 0; i < tags.nextTagPos; ++i) {\n      const tag = tags.tagPos[i].tag\n      if (tag <= 0 || !set.containedTag[tag]) {\n        invalidTags[invalidTags.length] = tag\n      }\n    }\n    return invalidTags\n  }\n\n  // list of tags that must be present\n  public missing (): number[] {\n    return this.missingRequired(this.segment.set, [])\n  }\n\n  public contains (tagOrName: number | string): boolean {\n    const tag: number = this.resolveTag(tagOrName)\n    const position: number = this.getPosition(tag)\n    return position >= 0\n  }\n\n  public getGroupInstance (i: number): MsgView {\n    const instance: SegmentDescription = this.segment.getInstance(i)\n    if (!instance) {\n      return null\n    }\n    return this.create(instance)\n  }\n\n  public getUndefined (): SegmentDescription | SegmentDescription[] {\n    return this.structure.layout['.undefined']\n  }\n\n  public undefinedForMsg (): string {\n    let msg: string = null\n    const undefinedTags = this.getUndefined()\n    if (undefinedTags) {\n      if (Array.isArray(undefinedTags)) {\n        msg = `undefined tags = ` + undefinedTags.map((e: SegmentDescription) => e.startTag.toString()).join(', ')\n      } else {\n        msg = `undefined tag = ${undefinedTags.startTag}`\n      }\n    }\n    return msg\n  }\n\n  public groupCount (): number {\n    const positions = this.segment.delimiterPositions\n    return positions ? positions.length : 0\n  }\n\n  public getString (tagOrName: number | string): string {\n    const tag: number = this.resolveTag(tagOrName)\n    if (tag == null) {\n      return null\n    }\n    const position: number = this.getPosition(tag)\n    if (position < 0) {\n      return null\n    }\n    return this.stringAtPosition(position)\n  }\n\n  public getStrings (tagOrName: number | string = -1): string[] {\n    if (tagOrName < 0) {\n      return this.allStrings()\n    }\n    const tag: number = this.resolveTag(tagOrName)\n    if (tag == null) {\n      return null\n    }\n    const positions: number[] = this.getPositions(tag)\n    if (positions == null) {\n      return null\n    }\n    return positions.map((position: number) => {\n      return this.stringAtPosition(position)\n    })\n  }\n\n  public getTyped (tagOrName: number | string): any {\n    const tag: number = this.resolveTag(tagOrName)\n    if (tag == null) {\n      return null\n    }\n    const field: SimpleFieldDefinition = this.structure.tags.definitions.tagToSimple[tag]\n    if (field == null) {\n      return null\n    }\n    return this.toTyped(field)\n  }\n\n  public getTypedTags (tagOrName: any[]): any[] {\n    return tagOrName.map((s) => this.getTyped(s))\n  }\n\n  public toObject (): any {\n    const segment: SegmentDescription = this.segment\n    if (segment.delimiterTag) {\n      switch (segment.set.type) {\n        case ContainedSetType.Group: {\n          return this.asInstances((segment.set as GroupFieldDefinition).name)\n        }\n        case ContainedSetType.Msg: {\n          // this is a batch of messages\n          const hdrView = this.getView('Hdr')\n          const batch: ILooseObject = {}\n          if (hdrView) {\n            batch[hdrView.segment.set.name] = hdrView.toObject()\n          }\n          batch[segment.name] = this.asInstances(segment.name)\n          return batch\n        }\n      }\n    }\n    return this.asLoose(segment.set)\n  }\n\n  public toString (): string {\n    return this.stringify(MsgView.asToken)\n  }\n\n  public toVerbose (): string {\n    return this.stringify(MsgView.asVerbose)\n  }\n\n  public toJson (): string {\n    return JSON.stringify(this.toObject(), null, 4)\n  }\n\n  public getView (name: string): MsgView {\n    const parts: string[] = name.split('.')\n    return parts.reduce((a: MsgView, current: string) => {\n      if (!a) {\n        return a\n      }\n      const structure = a.structure\n      const singleton: SegmentDescription = structure.firstContainedWithin(current, a.segment)\n      if (singleton) {\n        return a.create(singleton)\n      }\n      // is this a full name where abbreviation exists\n      const component: ContainedField = a.segment.set.localNameToField.get(current)\n      if (component) {\n        const abbreviated: SegmentDescription = structure.firstContainedWithin(component.name, a.segment)\n        if (abbreviated) {\n          return a.create(abbreviated)\n        }\n      }\n      return null\n    }, this as MsgView)\n  }\n\n  public abstract checksum (): number\n\n  public abstract clone (): MsgView\n\n  protected abstract create (singleton: SegmentDescription): MsgView\n\n  protected abstract stringAtPosition (position: number): string\n\n  protected abstract toTyped (field: SimpleFieldDefinition): any\n\n  protected resolveTag (tagOrName: number | string): number {\n    let tag: number\n    if (typeof(tagOrName) === 'string') {\n      let cf = this.segment.set.simple.get(tagOrName)\n      const f: SimpleFieldDefinition = cf ? cf.definition : this.structure.tags.definitions.simple.get(tagOrName)\n      if (f == null) {\n        return null\n      }\n      tag = f.tag\n    } else {\n      tag = tagOrName\n    }\n    return tag\n  }\n\n  // fetch all positions of a particular tag.\n  protected getPositions (tag: number): number[] {\n    const forwards: TagPos[] = this.sortedTagPosForwards\n    const backwards: TagPos[] = this.sortedTagPosBackwards\n    const position: number = this.binarySearch(tag)\n    if (position < 0) {\n      return null\n    }\n\n    const count: number = forwards.length\n    const last: number = count - 1\n    let end: number = position\n    while (end <= last) {\n      if (tag !== forwards[end].tag) {\n        break\n      }\n      ++end\n    }\n    // avoid backtracking over an array by scan forwards on a reversed copy\n    let start: number = last - position\n    while (start <= last) {\n      if (tag !== backwards[start].tag) {\n        break\n      }\n      ++start\n    }\n    const begin: number = last - (start - 1)\n    const len: number = end - begin\n    const positions: number[] = new Array(len)\n    for (let i: number = begin; i < end; ++i) {\n      positions[i - begin] = forwards[i].position\n    }\n    return positions\n  }\n\n  protected getPosition (tag: number): number {\n    const pos: number = this.binarySearch(tag)\n    if (pos >= 0) {\n      return this.sortedTagPosForwards[pos].position\n    } else {\n      return -1\n    }\n  }\n\n  private allStrings (): string[] {\n    const segment: SegmentDescription = this.segment\n    const range: number[] = []\n    for (let i: number = segment.startPosition; i <= segment.endPosition; ++i) {\n      range[range.length] = i\n    }\n    return range.map((i: number) => this.stringAtPosition(i))\n  }\n\n  private asInstances (name: string): ILooseObject[] {\n    const groupView: MsgView = this.getView(name)\n    if (groupView == null) {\n      return\n    }\n    const groupArray: ILooseObject[] = new Array(groupView.groupCount())\n    const count: number = groupView.groupCount()\n    for (let j: number = 0; j < count; ++j) {\n      const instance: MsgView = groupView.getGroupInstance(j)\n      groupArray[j] = instance.toObject()\n    }\n    return groupArray\n  }\n\n  private asLoose (def: ContainedFieldSet): ILooseObject {\n    const reducer = new SetReduce<ILooseObject>()\n    return reducer.reduce(def, {\n      group: (a: ILooseObject, field: ContainedGroupField) => this.asLooseGroup(a, field),\n      simple: (a: ILooseObject, field: ContainedSimpleField) => this.asLooseSimple(a, field),\n      component: (a: ILooseObject, field: ContainedComponentField) => this.asLooseComponent(a, field)\n    } as ITypeDispatcher<ILooseObject>, def.localAttribute.reduce((a: ILooseObject, sf: ContainedSimpleField) => {\n      const def = sf.definition\n      const position: number = this.getPosition(def.tag)\n      if (position >= 0) {\n        a[def.name] = this.toTyped(def)\n      }\n      return a\n    }, {} as ILooseObject))\n  }\n\n  private missingRequired (def: ContainedFieldSet, tags: number []): number[] {\n    const reducer = new SetReduce<number[]>()\n    return reducer.reduce(def, {\n      group: (a: number[], field: ContainedGroupField) => this.missingGroup(def, field, a),\n      simple: (a: number[], field: ContainedSimpleField) => this.missingSimple(field, a),\n      component: (a: number[], field: ContainedComponentField) => this.missingComponent(field, a)\n    } as ITypeDispatcher<number[]>, tags)\n  }\n\n  private missingSimple (sf: ContainedSimpleField, a: number[]) {\n    if (sf.required && this.getPosition(sf.definition.tag) < 0) {\n      a.push(sf.definition.tag)\n    }\n  }\n\n  private missingComponent (cf: ContainedComponentField, a: number[]) {\n    const view: MsgView = this.getView(cf.name)\n    if (view) {\n      view.missingRequired(cf.definition, a)\n    }\n  }\n\n  private missingGroup (def: ContainedFieldSet, gf: ContainedGroupField, tags: number []) {\n    const name = gf.definition.noOfField ? gf.definition.noOfField.name : def.name\n    const groupView: MsgView = this.getView(name) || this.getView(gf.definition.name)\n    if (groupView == null) {\n      return\n    }\n    const count: number = groupView.groupCount()\n    for (let j: number = 0; j < count; ++j) {\n      const instance: MsgView = groupView.getGroupInstance(j)\n      instance.missingRequired(gf.definition, tags)\n    }\n  }\n\n  private asLooseComponent (a: ILooseObject, cf: ContainedComponentField) {\n    const view: MsgView = this.getView(cf.name)\n    if (view) {\n      const component = view.toObject()\n      if (component) {\n        a[cf.definition.name] = component\n      }\n    }\n  }\n\n  private asLooseSimple (a: ILooseObject, sf: ContainedSimpleField) {\n    const def = sf.definition\n    const position: number = this.getPosition(def.tag)\n    if (position >= 0) {\n      const asSimple: any = this.toTyped(def)\n      if (asSimple != null) { // beware, may be false value\n        a[sf.name] = asSimple\n      }\n    }\n  }\n\n  private asLooseGroup (a: ILooseObject, gf: ContainedGroupField) {\n    const def = gf.definition\n    const name = def.noOfField ? def.noOfField.name : def.name\n    const instances: ILooseObject = this.asInstances(name) || this.asInstances(def.name)\n    if (instances) {\n      a[def.name] = instances\n    }\n  }\n\n  private binarySearch (tag: number): number {\n    let forwards = this.sortedTagPosForwards\n    if (!forwards) {\n      const segment = this.segment\n      forwards = this.sortedTagPosForwards = this.structure.tags.tagPos.slice(segment.startPosition, segment.endPosition + 1)\n      forwards.sort(TagPos.compare)\n      this.sortedTagPosBackwards = forwards.slice().reverse()\n    }\n    return TagPos.binarySearch(forwards, tag)\n  }\n\n  private stringify (getToken: (field: SimpleFieldDefinition, val: string, i: number, count: number, tp: TagPos) => string): string {\n    const structure = this.structure\n    const buffer: ElasticBuffer = new ElasticBuffer()\n    const segment: SegmentDescription = this.segment\n    const tags: Tags = structure.tags\n    const count: number = segment.endPosition - segment.startPosition\n    const simple: Dictionary<SimpleFieldDefinition> = tags.definitions.simple\n\n    for (let i: number = segment.startPosition; i <= segment.endPosition; ++i) {\n      const tagPos: TagPos = tags.tagPos[i]\n      const field: SimpleFieldDefinition = simple.get(tagPos.tag.toString())\n      const val: string = this.stringAtPosition(i)\n      const token = getToken(field, val, i - segment.startPosition, count, tagPos)\n      buffer.writeString(token)\n    }\n\n    return buffer.toString()\n  }\n}\n"]}