{"version":3,"file":"fixml-parser.js","sourceRoot":"","sources":["../../../src/buffer/fixml/fixml-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { MsgParser } from '../msg-parser'\nimport { Tags } from '../tag/tags'\nimport { SAXStream } from '../../dictionary'\nimport { FixDefinitions, MessageDefinition } from '../../dictionary/definition'\nimport { ContainedField, ContainedComponentField,\n  ContainedFieldType, ContainedGroupField,\n  ContainedSimpleField, ContainedFieldSet } from '../../dictionary/contained'\nimport { SegmentDescription } from '../segment/segment-description'\nimport { IJsFixConfig, IJsFixLogger } from '../../config'\nimport { MsgView } from '../msg-view'\nimport { Structure } from '../structure'\nimport { FixmlView } from './fixml-view'\nimport { Readable } from 'stream'\nimport { inject, injectable } from 'tsyringe'\nimport { DITokens } from '../../runtime/di-tokens'\nimport { ISaxNode } from '../../dictionary/sax-node'\nimport { SegmentType } from '../segment/segment-type'\n\n@injectable()\nexport class FiXmlParser extends MsgParser {\n  private readonly locations: Tags\n  private values: string[] = []\n  private readonly saxStream: SAXStream\n  private readonly definitions: FixDefinitions\n  private readonly segments: SegmentDescription[] = []\n  private readonly segmentStack: SegmentDescription[] = []\n  private readonly logger: IJsFixLogger\n  private last: SegmentDescription\n  private raw: string\n\n  constructor (@inject(DITokens.IJsFixConfig) public readonly config: IJsFixConfig,\n               @inject(DITokens.readStream) public readonly readStream: Readable,\n               @inject(DITokens.maxMessageLocations) public readonly maxMessageLocations: number = 10 * 1024) {\n    super()\n    this.definitions = this.config.definitions\n    const description = config.description\n    const me = description.application.name\n    this.logger = config.logFactory.logger(`${me}:FiXmlParser`)\n    this.saxStream = require('sax').createStream(true, {})\n    this.locations = new Tags(this.definitions, maxMessageLocations)\n    this.logger.info('subscribe to stream')\n    this.subscribe()\n  }\n\n  private reset (): void {\n    const segments = this.segments\n    while (segments.length > 0) {\n      segments.pop()\n    }\n    const stack = this.segmentStack\n    this.last = null\n    this.raw = null\n    this.values = []\n    this.locations.reset()\n    while (stack.length) {\n      stack.pop()\n    }\n  }\n\n  private subscribe (): void {\n    const writeStream = this.saxStream\n    const readStream = this.readStream\n    let instance = this\n    readStream.pipe(writeStream).on('ready', () => {\n      this.logger.info('stream close event')\n      this.emit('close')\n    })\n    readStream.on('error', (e) => {\n      this.logger.error(e)\n      this.emit('error', e)\n    })\n    readStream.on('end', () => {\n      this.logger.info('stream end event')\n      this.emit('end')\n    })\n    writeStream.on('data', (i: Buffer) => {\n      if (instance.last) {\n        instance.emit('decoded', instance.last.name, i.toString())\n      } else {\n        this.raw = i.toString()\n      }\n    })\n\n    writeStream.on('opentag', (node) => {\n      const stack = this.segmentStack\n      const saxNode: ISaxNode = node as ISaxNode\n      switch (saxNode.name) {\n        case 'FIXML':\n          this.reset()\n          break\n\n        case 'Batch': {\n          const locations = this.locations\n          const ptr = locations.nextTagPos - 1\n          const segment: SegmentDescription = new SegmentDescription(saxNode.name,\n            -1,\n            null,\n            ptr,\n            stack.length,\n            SegmentType.Batch)\n          segment.startPosition = 0\n          stack.push(segment)\n          break\n        }\n\n        case 'Hdr': {\n          this.hdr(saxNode)\n          break\n        }\n\n        default: {\n          const stack = this.segmentStack\n          const isBatch: boolean = stack.length === 1 && stack[0].type === SegmentType.Batch\n          const isMsg: boolean = stack.length === 0\n          if (isMsg) {\n            // one single message\n            this.msg(saxNode)\n          } else if (isBatch) {\n            // one message within a batch or it\n            this.msgInBatch(saxNode)\n          } else {\n            // or it is a structure within a message\n            this.element(saxNode)\n          }\n        }\n      }\n    })\n    writeStream.on('closetag', (name: string) => {\n      this.pop(name)\n    })\n    writeStream.on('error', (e: Error) => {\n      this.emit('error', e)\n    })\n  }\n\n  private hdr (saxNode: ISaxNode): void {\n    const stack = this.segmentStack\n    if (stack.length === 0) {\n      throw new Error(`Hdr not expected before batch or message ${saxNode.name}`)\n    }\n    let peek: SegmentDescription = stack[stack.length - 1]\n    switch (peek.type) {\n      case SegmentType.Batch: {\n        // manually handle this component\n        const hdr = this.definitions.component.get('StandardHeader')\n        const segment: SegmentDescription = this.parseAttributes(saxNode.name, hdr, saxNode, SegmentType.Component)\n        this.segmentStack.push(segment)\n        break\n      }\n\n      case SegmentType.Msg: {\n        this.element(saxNode)\n        break\n      }\n\n      default:\n        throw new Error(`Hdr not expected before batch or message ${saxNode.name}`)\n    }\n  }\n\n  private msgInBatch (saxNode: ISaxNode): void {\n    this.logger.info(` ${saxNode.name}: start batch`)\n    const locations = this.locations\n    const batch = this.segmentStack[0]\n    const ptr = locations.nextTagPos\n    if (!batch.delimiterPositions) {\n      batch.startGroup(-1)\n    }\n    batch.addDelimiterPosition(ptr)\n    this.logger.debug(` ${saxNode.name}: begin parse msg ${batch.delimiterPositions.length} in batch`)\n    this.msg(saxNode, true)\n  }\n\n  private getView (): MsgView {\n    const structure: Structure = new Structure(this.locations, this.segments)\n    const last = structure.segments[structure.segments.length - 1]\n    return new FixmlView(last, this.values, structure)\n  }\n\n  private pop (name: string): SegmentDescription {\n    const locations = this.locations\n    const stack = this.segmentStack\n    const segments = this.segments\n    while (stack.length > 0) {\n      const pop = stack.pop()\n      const ptr = locations.nextTagPos - 1\n      pop.end(segments.length, ptr, locations.tagPos[ptr].tag)\n      segments[segments.length] = pop\n      switch (pop.type) {\n        case SegmentType.Msg: {\n          // raise msg event\n          const last = segments[segments.length - 1]\n          this.last = last\n          this.emit('msg', last.name, this.getView())\n          if (this.raw) {\n            this.emit('decoded', this.last.name, this.raw)\n            this.raw = null\n          }\n          break\n        }\n        case SegmentType.Batch: {\n          const last = segments[segments.length - 1]\n          this.logger.debug(`emit batch with ${pop.delimiterPositions.length} elements`)\n          this.emit('batch', last.set.abbreviation, this.getView())\n          break\n        }\n      }\n      if (pop.name === name) {\n        return pop\n      }\n    }\n    return null\n  }\n\n  private startGroup (saxNode: ISaxNode, gf: ContainedGroupField) {\n    const locations = this.locations\n    const stack: SegmentDescription[] = this.segmentStack\n    const ptr = locations.nextTagPos\n    const def = gf.definition\n    const segment: SegmentDescription = this.parseAttributes(saxNode.name, def, saxNode, SegmentType.Component)\n    const group: SegmentDescription = new SegmentDescription(def.name,\n      locations.tagPos[ptr].tag,\n      def,\n      ptr,\n      stack.length,\n      SegmentType.Group)\n    group.startGroup(locations.tagPos[ptr].tag)\n    group.addDelimiterPosition(ptr)\n    stack.push(group)\n    stack.push(segment)\n  }\n\n  private getNextField (saxNode: ISaxNode): ContainedField {\n    const stack: SegmentDescription[] = this.segmentStack\n    while (stack.length > 0) {\n      let peek: SegmentDescription = stack[stack.length - 1]\n      let field = peek.set.localNameToField.get(saxNode.name)\n      if (field) {\n        return field\n      }\n      // if this is a group of the same type as already on stack\n      // take the field from the next level up\n      if (peek.type === SegmentType.Group && stack.length > 1) {\n        const contained = stack[stack.length - 2].set.localNameToField.get(saxNode.name)\n        if (contained instanceof ContainedGroupField) {\n          if (contained.definition.name === peek.name) {\n            // this is the same type for next instance in the same group.\n            return contained\n          }\n        }\n      }\n      // then have ended previous group. Pop and return to see if this field lives on the parent\n      const locations = this.locations\n      const ptr = locations.nextTagPos - 1\n      const pop = stack.pop()\n      const segments = this.segments\n      pop.end(segments.length, ptr, locations.tagPos[ptr].tag)\n      segments[segments.length] = pop\n    }\n    return null\n  }\n\n  private dispatch (saxNode: ISaxNode, field: ContainedField) {\n    switch (field.type) {\n      case ContainedFieldType.Component: {\n        const cf: ContainedComponentField = field as ContainedComponentField\n        const segment: SegmentDescription = this.parseAttributes(saxNode.name, cf.definition, saxNode, SegmentType.Component)\n        this.segmentStack.push(segment)\n        break\n      }\n\n      case ContainedFieldType.Group: {\n        this.dispatchGroup(saxNode, field as ContainedGroupField)\n        break\n      }\n    }\n  }\n\n  private dispatchGroup (saxNode: ISaxNode, gf: ContainedGroupField): void {\n    const stack: SegmentDescription[] = this.segmentStack\n    const peek: SegmentDescription = stack[stack.length - 1]\n    switch (peek.type) {\n      case SegmentType.Msg:\n      case SegmentType.Component: {\n        this.startGroup(saxNode, gf)\n        break\n      }\n\n      case SegmentType.Group: {\n        if (gf.name === saxNode.name) {\n          const ptr = this.locations.nextTagPos\n          peek.addDelimiterPosition(ptr)\n          stack[stack.length] = this.parseAttributes(saxNode.name, gf.definition, saxNode, SegmentType.Component)\n        } else {\n          throw new Error(`expected another group instance of ${gf.name} but got ${saxNode.name}`)\n        }\n        break\n      }\n\n      default:\n        throw new Error(`dispatchGroup has field ${gf.name} peek type ${peek.type}`)\n    }\n  }\n\n  private element (saxNode: ISaxNode): void {\n    // may terminate a group and move fields\n    const field = this.getNextField(saxNode)\n    if (!field) {\n      const stack: SegmentDescription[] = this.segmentStack\n      let peek: SegmentDescription = stack[stack.length - 1]\n      throw new Error(`field ${saxNode.name} not known in set ${peek.set.name}`)\n    }\n    this.dispatch(saxNode, field)\n  }\n\n  private msg (saxNode: ISaxNode, inBatch: boolean = false): void {\n    this.logger.debug(`${saxNode.name}: begin parse msg`)\n    const type: string = saxNode.name\n    const def: MessageDefinition = this.definitions.message.get(type)\n    if (!def) {\n      throw new Error(`unknown message type ${type}`)\n    }\n    if (inBatch) {\n      const batch = this.segmentStack[0]\n      batch.set = def\n    }\n    const segment: SegmentDescription = this.parseAttributes(type, def, saxNode, SegmentType.Msg)\n    this.segmentStack.push(segment)\n  }\n\n  private parseAttributes (name: string, set: ContainedFieldSet, saxNode: ISaxNode, type: SegmentType): SegmentDescription {\n    const locations = this.locations\n    const attributes = saxNode.attributes\n    const values = this.values\n    let ptr: number\n    if (attributes) {\n      const keys: string[] = Object.keys(attributes)\n      ptr = keys.length > 0 ? locations.nextTagPos : locations.nextTagPos - 1\n      for (let j: number = 0; j < keys.length; ++j) {\n        const k: string = keys[j]\n        const v: string = attributes[k]\n        const field: ContainedSimpleField = set.localNameToField.get(k) as ContainedSimpleField\n        if (!field) {\n          this.logger.warning(`no field ${k} in set ${set.name}`)\n          locations.store(j, 1, -1)\n        } else {\n          locations.store(j, 1, field.definition.tag)\n        }\n        values[values.length] = v\n      }\n      return new SegmentDescription(name, locations.tagPos[ptr].tag, set, ptr, this.segmentStack.length, type)\n    }\n  }\n}\n"]}