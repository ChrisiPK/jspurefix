{"version":3,"file":"ascii-segment-parser.js","sourceRoot":"","sources":["../../../src/buffer/ascii/ascii-segment-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { SegmentDescription } from '../segment/segment-description'\nimport { Structure } from '../structure'\nimport { Tags } from '../tag/tags'\nimport {\n  FixDefinitions,\n  MessageDefinition\n} from '../../dictionary/definition'\nimport {\n  ContainedComponentField,\n  ContainedGroupField,\n  ContainedSimpleField,\n  ContainedFieldType\n} from '../../dictionary/contained'\nimport { inject, injectable } from 'tsyringe'\nimport { DITokens } from '../../runtime/di-tokens'\nimport { SegmentType } from '../segment/segment-type'\n\n// this takes linear time i.e. it constantly makes forward progress\n// one tag at a time\n\n@injectable()\nexport class AsciiSegmentParser {\n\n  constructor (@inject(DITokens.Definitions) public readonly definitions: FixDefinitions) {\n  }\n\n  public parse (msgType: string, tags: Tags, last: number): Structure {\n    // completed segments in that they are fully parsed\n    const segments: SegmentDescription[] = []\n    const msgDefinition: MessageDefinition = this.definitions.message.get(msgType)\n    if (!msgDefinition) {\n      return null\n    }\n    // in process of being discovered and may have any amount of depth\n    // i.e. a component containing a repeated group of components\n    // with sub-groups of components\n    const structureStack: SegmentDescription[] = []\n    let currentTagPosition: number = 0\n    let peek: SegmentDescription\n\n    // having finished one segments keep unwinding until tag matches further up stack\n    function unwind (tag: number): void {\n      while (structureStack.length > 1) {\n        const done: SegmentDescription = structureStack.pop()\n        done.end(segments.length, currentTagPosition - 1, tags.tagPos[currentTagPosition - 1].tag)\n        segments.push(done)\n        peek = structureStack[structureStack.length - 1]\n        if (peek.set.containedTag[tag]) {\n          // unwound to point this tag lives in this set.\n          break\n        }\n        if (peek.type === SegmentType.Msg) {\n          // this is unknown tag and it is not part of trailer so raise unknown\n          break\n        }\n      }\n    }\n\n    function examine (tag: number): SegmentDescription {\n      let structure: SegmentDescription = null\n      switch (peek.currentField.type) {\n\n        case ContainedFieldType.Simple: {\n          const sf: ContainedSimpleField = peek.currentField as ContainedSimpleField\n          if (sf.definition.tag === tag) {\n            currentTagPosition = currentTagPosition + 1\n          }\n          break\n        }\n        // moving deeper into structure, start a new context\n        case ContainedFieldType.Component: {\n          const cf: ContainedComponentField = peek.currentField as ContainedComponentField\n          structure = new SegmentDescription(cf.name, tag, cf.definition,\n                        currentTagPosition, structureStack.length, SegmentType.Component)\n          break\n        }\n        // for a group also need to know where all delimiters are positioned\n        case ContainedFieldType.Group: {\n          const gf: ContainedComponentField = peek.currentField as ContainedGroupField\n          structure = new SegmentDescription(gf.name, tag, gf.definition,\n                        currentTagPosition, structureStack.length, SegmentType.Group)\n          currentTagPosition = currentTagPosition + 1\n          structure.startGroup(tags.tagPos[currentTagPosition].tag)\n          break\n        }\n\n        default:\n          throw new Error(`unknown tag type ${tag}`)\n      }\n\n      return structure\n    }\n\n    function groupDelimiter (tag: number): boolean {\n      let delimiter: boolean = false\n      if (tag === peek.delimiterTag) {\n        peek.addDelimiterPosition(currentTagPosition)\n      } else if (structureStack.length > 1) {\n                // if a group is represented by a repeated component, then the tag representing delimiter\n                // needs to be added further up stack to group itself.\n        delimiter = structureStack[structureStack.length - 2].groupAddDelimiter(tag, currentTagPosition)\n      }\n      return delimiter\n    }\n\n    function gap (tag: number): void {\n      const gap = new SegmentDescription('.undefined', tag, peek.set,\n        currentTagPosition, structureStack.length, SegmentType.Gap)\n      gap.end(segments.length, currentTagPosition, tag)\n      segments.push(gap)\n      currentTagPosition++\n    }\n\n    function discover (): void {\n      while (currentTagPosition <= last) {\n        const tag: number = tags.tagPos[currentTagPosition].tag\n        peek = structureStack[structureStack.length - 1]\n        peek.setCurrentField(tag)\n        if (!peek.set.containedTag[tag] || groupDelimiter(tag)) {\n          // unravelled all way back to root hence this is not recognised\n          const unknown = peek.type === SegmentType.Msg\n          if (unknown) {\n            gap(tag)\n          } else if (structureStack.length > 1) {\n            // move back up the segments and save the finished group / component\n            unwind(tag)\n          }\n          continue\n        }\n        const structure = examine(tag)\n        if (structure) {\n          structureStack.push(structure)\n        }\n      }\n    }\n\n    function clean (): void {\n      // any remainder components can be closed.\n      while (structureStack.length > 0) {\n        const done: SegmentDescription = structureStack.pop()\n        done.end(segments.length, currentTagPosition - 1, tags.tagPos[currentTagPosition - 1].tag)\n        segments[segments.length] = done\n      }\n      // logically reverse the trailer and message so trailer is last in list.\n      const m1 = segments.length - 1\n      const m2 = segments.length - 2\n      const tmp = segments[m1]\n      segments[m1] = segments[m2]\n      segments[m2] = tmp\n    }\n\n    const msgStructure = new SegmentDescription(msgDefinition.name, tags.tagPos[0].tag, msgDefinition,\n      currentTagPosition, structureStack.length, SegmentType.Msg)\n    structureStack.push(msgStructure)\n    discover()\n    clean()\n\n    // now know where all components and groups are positioned within message\n    return new Structure(tags, segments)\n  }\n}\n"]}