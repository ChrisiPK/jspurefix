{"version":3,"file":"ascii-encoder.js","sourceRoot":"","sources":["../../../src/buffer/ascii/ascii-encoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { ILooseObject } from '../../collections/collection'\nimport {\n  ContainedGroupField, ContainedSimpleField,\n  ContainedFieldSet, ContainedField,\n  ContainedComponentField, FieldsDispatch\n} from '../../dictionary/contained'\nimport { SimpleFieldDefinition, FixDefinitions } from '../../dictionary/definition'\nimport { MsgEncoder } from '../msg-encoder'\nimport { ElasticBuffer } from '../elastic-buffer'\nimport { TimeFormatter } from './time-formatter'\nimport { ITimeFormatter } from './itime-formatter'\nimport { AsciiChars } from './ascii-chars'\nimport { Tags } from '../tag/tags'\nimport { TagType } from '../tag/tag-type'\n\nexport class AsciiEncoder extends MsgEncoder {\n\n  public bodyLengthPos: number\n  public msgTypePos: number\n  public tags: Tags\n  public checkGroups: boolean = true\n\n  constructor (public readonly buffer: ElasticBuffer,\n               public readonly definitions: FixDefinitions,\n               public readonly timeFormatter: ITimeFormatter = new TimeFormatter(buffer),\n               public readonly delimiter: number = AsciiChars.Soh,\n               public readonly logDelimiter: number = AsciiChars.Pipe) {\n    super(definitions)\n    this.tags = new Tags(definitions)\n  }\n\n  public trim (): Buffer {\n    const b = this.buffer.copy()\n    const delimiter = this.delimiter\n    const logDelimiter = this.logDelimiter\n    const tags = this.tags\n    if (delimiter !== logDelimiter) {\n      for (let p = 0; p < tags.nextTagPos; ++p) {\n        const tagPos = tags.tagPos[p]\n        b.writeUInt8(delimiter, tagPos.start + tagPos.len)\n      }\n    }\n\n    return b\n  }\n\n  // only reset tags after entire message is encoded - <hdr>body<trl>\n\n  public reset (): void {\n    this.buffer.reset()\n    this.tags.reset()\n  }\n\n  public encodeSet (objectToEncode: ILooseObject, set: ContainedFieldSet): void {\n    const summary: AsciiEncodeSetSummary = new AsciiEncodeSetSummary()\n    this.encodeObject(objectToEncode, set, summary)\n  }\n\n  private encodeObject (objectToEncode: ILooseObject, set: ContainedFieldSet, state: AsciiEncodeSetSummary): void {\n    const fields: ContainedField[] = this.getFields(set, objectToEncode)\n    new FieldsDispatch().dispatchFields(fields, {\n      simple: (sf: ContainedSimpleField) => {\n        const val: any = objectToEncode[sf.name]\n        // Empty strings are omitted as they result in empty values for tags, which are considered malformed.\n        if (val != null && val !== '') {\n          if (state.count === 0) {\n            state.firstSimple = sf\n          }\n          state.lastSimple = sf\n          state.count++\n          this.encodeSimple(objectToEncode, set, sf, val)\n        }\n      },\n      component: (cf: ContainedComponentField) => {\n        const instance: ILooseObject = objectToEncode[cf.definition.name]\n        if (instance) {\n          this.encodeObject(instance, cf.definition, state)\n        }\n      },\n      group: (gf: ContainedGroupField) => {\n        this.encodeInstances(objectToEncode, gf)\n      }\n    })\n  }\n\n  private getFields (set: ContainedFieldSet, o: ILooseObject): ContainedField[] {\n    const keys: string[] = Object.keys(o)\n    let j: number = 0\n    const fields: ContainedField[] = keys.reduce((a: ContainedField[], current: string) => {\n      const field: ContainedField = set.localNameToField.get(current)\n      if (field) {\n        a[j++] = field\n      }\n      return a\n    }, new Array(keys.length))\n    fields.sort((a: ContainedField, b: ContainedField) => a.position - b.position)\n    return fields\n  }\n\n  private encodeInstances (o: ILooseObject, gf: ContainedGroupField): void {\n    const noOfField: SimpleFieldDefinition = gf.definition.noOfField\n    const instances: ILooseObject[] = o[gf.name] || o[noOfField.name]\n\n    const buffer = this.buffer\n    if (!Array.isArray(instances)) {\n      throw new Error(`expected array instance for group ${noOfField.name}`)\n    }\n    if (instances) {\n      const validator = new GroupValidator(gf)\n      const test: AsciiEncodeSetSummary = validator.test\n\n      // a repeated group has number of instances at the start of group\n      this.WriteTagEquals(noOfField.tag)\n      const posValBegin = buffer.getPos()\n      buffer.writeWholeNumber(instances.length)\n      this.writeDelimiter(posValBegin, noOfField.tag)\n      for (let field = 0; field < instances.length; ++field) {\n        const instance: ILooseObject = instances[field]\n        test.reset()\n        const summary = validator.getSummary(field)\n        this.encodeObject(instance, gf.definition, summary)\n        if (this.checkGroups) {\n          validator.assertInstanceValid(field)\n        }\n      }\n    }\n  }\n\n  private WriteTagEquals (tag: number): void {\n    const buffer = this.buffer\n    buffer.writeWholeNumber(tag)\n    buffer.writeChar(AsciiChars.Equal)\n  }\n\n  private writeDelimiter (posValBegin: number, tag: number): void {\n    const delimiter = this.logDelimiter\n    const buffer = this.buffer\n    this.tags.store(posValBegin, buffer.getPos() - posValBegin, tag)\n    buffer.writeChar(delimiter)\n  }\n\n  private encodeSimple (o: ILooseObject, set: ContainedFieldSet, sf: ContainedSimpleField, val: any): void {\n    const definition = sf.definition\n    const tag: number = definition.tag\n    const buffer = this.buffer\n    const delimiter = this.logDelimiter\n    const tf = this.timeFormatter\n    const pos = buffer.getPos()\n    let posValBegin = 0\n\n    let tagType: TagType\n    if (typeof val === 'string') {\n      switch (definition.tagType) {\n        case TagType.Boolean: {\n          tagType = definition.tagType\n          const vs: string = val\n          const first: string = vs.length > 0 ? vs.charAt(0) : 'N'\n          val = first === 'Y' || first === 'T'\n          break\n        }\n        default: {\n          tagType = TagType.String\n        }\n      }\n    } else {\n      tagType = definition.tagType\n    }\n\n    switch (tagType) {\n\n      case TagType.RawData: {\n        // may need to first write raw message length (see below)\n        break\n      }\n\n      default: {\n        this.WriteTagEquals(tag)\n        posValBegin = buffer.getPos()\n        break\n      }\n    }\n\n    switch (tagType) {\n      case TagType.String: {\n        buffer.writeString(val as string)\n        break\n      }\n\n      case TagType.Float: {\n        buffer.writeNumber(val as number)\n        break\n      }\n\n      case TagType.Int:\n      case TagType.Length: {\n        buffer.writeWholeNumber(val as number)\n        break\n      }\n\n      case TagType.Boolean: {\n        buffer.writeBoolean(val as boolean)\n        break\n      }\n\n      case TagType.UtcTimestamp: {\n        tf.writeUtcTimestamp(val as Date)\n        break\n      }\n\n      case TagType.UtcTimeOnly: {\n        tf.writeUtcTime(val as Date)\n        break\n      }\n\n      case TagType.UtcDateOnly: {\n        tf.writeUtcDate(val as Date)\n        break\n      }\n\n      case TagType.LocalDate: {\n        tf.writeLocalDate(val as Date)\n        break\n      }\n\n      case TagType.RawData: {\n        const b = val as Buffer\n        const lenField: ContainedSimpleField = set.fields[sf.position - 1] as ContainedSimpleField\n        if (o[lenField.name] == null) {\n          this.WriteTagEquals(lenField.definition.tag)\n          buffer.writeWholeNumber(b.length)\n          buffer.writeChar(delimiter)\n        }\n        this.WriteTagEquals(tag)\n        buffer.writeBuffer(b)\n        posValBegin = buffer.getPos()\n        break\n      }\n\n      default: {\n        buffer.writeString(val as string)\n        break\n      }\n    }\n\n    this.writeDelimiter(posValBegin, tag)\n\n    switch (tag) {\n      case Tags.BodyLengthTag:\n        this.bodyLengthPos = pos + 2\n        break\n\n      case Tags.MsgTag:\n        this.msgTypePos = pos\n        break\n    }\n  }\n}\n\nclass GroupValidator {\n  constructor (public readonly gf: ContainedGroupField,\n    public readonly first: AsciiEncodeSetSummary = new AsciiEncodeSetSummary(),\n    public readonly test: AsciiEncodeSetSummary = new AsciiEncodeSetSummary()) {\n  }\n\n  getSummary (field: number) {\n    return field === 0 ? this.first : this.test\n  }\n\n  assertInstanceValid (field: number): void {\n    const first = this.first\n    const test = this.test\n    if (field === 0 && first.empty()) {\n      throw new Error(`first group instance has no delimeter present ${this.gf.name}`)\n    }\n    if (field > 0 && test.empty()) {\n      throw new Error(`group instance [${field}] has no delimeter present ${this.gf.name}`)\n    }\n    if (field > 0) {\n      const firstTag = first.firstSimple.definition.tag\n      const tag = test.firstSimple.definition.tag\n      if (firstTag !== tag) {\n        throw new Error(`group instance [${field}] inconsisent delimeter ${tag} expected tag ${firstTag}`)\n      }\n    }\n  }\n}\n\nclass AsciiEncodeSetSummary {\n  constructor (public firstSimple: ContainedSimpleField = null,\n    public lastSimple: ContainedSimpleField = null,\n    public count: number = 0) {\n  }\n  public reset (): void {\n    this.firstSimple = null\n    this.lastSimple = null\n    this.count = 0\n  }\n  public empty (): boolean {\n    return this.firstSimple === null || this.count === 0\n  }\n}\n"]}