{"version":3,"file":"ascii-parser.js","sourceRoot":"","sources":["../../../src/buffer/ascii/ascii-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { AsciiChars } from './ascii-chars'\nimport { AsciiView } from './ascii-view'\nimport { AsciiSegmentParser } from './ascii-segment-parser'\nimport { AsciiParserState } from './ascii-parser-state'\nimport { Structure } from '../structure'\nimport { Tags } from '../tag/tags'\nimport { MsgParser } from '../msg-parser'\nimport { MsgView } from '../msg-view'\nimport { Readable } from 'stream'\nimport { ElasticBuffer } from '../elastic-buffer'\nimport { SegmentDescription } from '../segment/segment-description'\nimport { ParseState } from './parse-state'\nimport { IJsFixConfig } from '../../config'\nimport { inject, injectable } from 'tsyringe'\nimport { DITokens } from '../../runtime/di-tokens'\nimport { SegmentType } from '../segment/segment-type'\n\n@injectable()\nexport class AsciiParser extends MsgParser {\n  private static nextId: number = 0\n  public readonly id: number\n  public readonly state: AsciiParserState\n  private readonly segmentParser: AsciiSegmentParser\n  public readonly delimiter: number\n  public readonly writeDelimiter: number\n\n  // allocate enough in receive buffer so buffer does not constant resize back after large messages\n  // want to keep one slice of memory and constantly reuse it\n\n  constructor (@inject(DITokens.IJsFixConfig) public readonly config: IJsFixConfig,\n               @inject(DITokens.readStream) public readonly readStream: Readable,\n               @inject(DITokens.ParseBuffer) protected readonly receivingBuffer: ElasticBuffer) {\n    super()\n\n    this.delimiter = config.delimiter\n    this.writeDelimiter = config.logDelimiter || AsciiChars.Pipe\n    const definitions = config.definitions\n    this.id = AsciiParser.nextId++\n    this.segmentParser = config.sessionContainer.resolve<AsciiSegmentParser>(AsciiSegmentParser)\n    this.state = config.sessionContainer.resolve<AsciiParserState>(AsciiParserState)\n    this.state.locations = new Tags(definitions, this.receivingBuffer.size / 10)\n    this.state.beginMessage()\n    if (readStream !== null) {\n      this.subscribe()\n    }\n  }\n\n  private subscribe (): void {\n    const inst: AsciiParser = this\n    const Writable = require('stream').Writable\n    const stream = this.readStream\n\n    const receiver = new Writable({\n      write: (data: Buffer, _: any, done: Function) => {\n        try {\n          inst.parse(data, data.length)\n          done()\n        } catch (e) {\n          done(e)\n        }\n      }\n    })\n    receiver.on('error', (e: Error) => {\n      this.emit('error', e)\n    })\n\n    // receive from say a socket or file and pipe to parser which discovers messages\n    stream.pipe(receiver).on('finish', () => {\n      this.emit('done')\n    })\n    stream.on('error', (e) => {\n      this.emit('error', e)\n    })\n    stream.on('end', () => {\n      this.emit('end')\n    })\n  }\n\n  private msg (ptr: number): void {\n    const receivingBuffer: ElasticBuffer = this.receivingBuffer\n    const state = this.state\n    if (this.listeners('decoded')) {\n      this.emit('decoded', state.msgType, receivingBuffer, ptr)\n    }\n    this.emit('msg', state.msgType, this.getView(ptr))\n    state.beginMessage()\n  }\n\n  public parseText (text: string) {\n    const buff = Buffer.from(text)\n    this.parse(buff, buff.length)\n  }\n\n  private parse (readBuffer: Buffer, end: number): void {\n    const state = this.state\n    const eq: number = AsciiChars.Eq\n    const zero: number = AsciiChars.Zero\n    const nine: number = AsciiChars.Nine\n    const delimiter: number = this.delimiter\n    const writeDelimiter: number = this.writeDelimiter\n    const receivingBuffer: ElasticBuffer = this.receivingBuffer\n    const switchDelimiter = writeDelimiter !== delimiter\n    let readPtr: number = 0\n\n    while (readPtr < end) {\n      let charAtPos: number = readBuffer[readPtr]\n\n      const writePtr = receivingBuffer.saveChar(charAtPos) - 1\n      switch (state.parseState) {\n\n        case ParseState.MsgComplete: {\n          this.msg(writePtr)\n          continue\n        }\n\n        case ParseState.BeginField: {\n          const atDigit: boolean = charAtPos >= zero && charAtPos <= nine\n          if (atDigit) {\n            state.beginTag(writePtr)\n          }\n          break\n        }\n\n        case ParseState.ParsingTag: {\n          const isEquals: boolean = charAtPos === eq\n          if (isEquals) {\n            state.endTag(writePtr)\n          }\n          break\n        }\n\n        case ParseState.ParsingRawData: {\n          // keep skipping until length read, regardless of delimiter or not\n          if (state.incRaw()) {\n            // having consumed the raw field expecting delimiter\n            if (charAtPos === delimiter) {\n              if (switchDelimiter) {\n                receivingBuffer.switchChar(writeDelimiter)\n              }\n              state.store()\n            } else {\n              throw new Error(`delimiter (${delimiter}) expected at position ${readPtr} when value is ${charAtPos}`)\n            }\n          }\n          break\n        }\n\n        case ParseState.ParsingRawDataLength:\n        case ParseState.ParsingValue: {\n          if (charAtPos === delimiter) {\n            if (switchDelimiter) {\n              receivingBuffer.switchChar(writeDelimiter)\n            }\n            state.store()\n          }\n          break\n        }\n\n        default: {\n          throw new Error(`fix parser in unknown state ${state}`)\n        }\n      }\n      readPtr++\n    }\n\n    switch (state.parseState) {\n      case ParseState.MsgComplete: {\n        this.msg(receivingBuffer.getPos())\n        break\n      }\n    }\n  }\n\n  private getView (ptr: number): MsgView {\n    const state = this.state\n    const locations = state.locations\n    const source = this.receivingBuffer\n    const delimiter = this.delimiter\n    const replace = this.writeDelimiter\n    if (state.message) {\n      const structure: Structure = this.segmentParser.parse(state.msgType, locations,\n        locations.nextTagPos - 1)\n      return new AsciiView(structure.msg(),\n        source,\n        structure,\n        ptr,\n        delimiter,\n        replace)\n    }\n\n    const structure = new Structure(locations, [])\n    const segment = new SegmentDescription('unknown', locations.tagPos[0].tag, null, 0, 1, SegmentType.Unknown)\n    segment.endPosition = locations.nextTagPos - 1\n    return new AsciiView(segment, source, structure, ptr, delimiter, replace)\n  }\n}\n"]}