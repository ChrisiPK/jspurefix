{"version":3,"file":"encode-proxy.js","sourceRoot":"","sources":["../../src/buffer/encode-proxy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ILooseObject } from '../collections/collection'\nimport { FixDefinitions, MessageDefinition, SimpleFieldDefinition } from '../dictionary/definition'\nimport {\n  ContainedComponentField, ContainedField,\n  ContainedFieldSet, ContainedFieldType,\n  ContainedGroupField,\n  ContainedSimpleField\n} from '../dictionary/contained'\nimport { TagType } from './tag/tag-type'\n\nexport class EncodeProxy {\n  constructor (public readonly definitions: FixDefinitions) {\n  }\n\n  private static SimpleFieldCheck (field: ContainedSimpleField, val: any): void {\n    const definition: SimpleFieldDefinition = field.definition\n    if (definition.isEnum()) {\n      const resolved: boolean = definition.containsEnum(val)\n      if (!resolved) {\n        throw new Error(`enum field ${field.name} does not support \"${val}\"`)\n      }\n    }\n    switch (definition.tagType) {\n      case TagType.LocalDate:\n      case TagType.UtcTimeOnly:\n      case TagType.UtcDateOnly:\n      case TagType.UtcTimestamp: {\n        const isDate: boolean = val instanceof Date\n        if (!isDate) {\n          throw new Error(`field ${field.name} expects Date but receives \"${typeof val}\"`)\n        }\n        break\n      }\n\n      case TagType.Boolean: {\n        if (typeof(val) !== typeof(true)) {\n          throw new Error(`field ${field.name} expects boolean but receives \"${typeof val}\"`)\n        }\n        break\n      }\n\n      case TagType.String: {\n        if (typeof(val) !== 'string') {\n          throw new Error(`field ${field.name} expects string but receives \"${typeof val}\"`)\n        }\n        break\n      }\n\n      case TagType.RawData: {\n        const isBuffer: boolean = val instanceof Buffer\n        if (!isBuffer) {\n          throw new Error(`field ${field.name} expects Buffer but receives \"${typeof val}\"`)\n        }\n        break\n      }\n\n      case TagType.Int:\n      case TagType.Float:\n      case TagType.Length: {\n        if (isNaN(val)) {\n          throw new Error(`field ${field.name} expects number but receives \"${typeof val}\"`)\n        }\n        break\n      }\n    }\n  }\n\n  private static checkProperties (wrapped: ILooseObject, val: ILooseObject): ILooseObject {\n    const keys: string[] = Object.keys(val)\n    for (let k of keys) {\n      wrapped[k] = val[k]\n    }\n    return wrapped\n  }\n\n  private static ComponentFieldCheck (field: ContainedComponentField, val: any): object {\n    const isComplex: boolean = typeof val === 'object'\n    if (!isComplex) {\n      throw new Error(`type ${field.name} is a component but is given type \"${typeof val}\"`)\n    }\n    const cf: ContainedComponentField = field\n    return EncodeProxy.checkProperties(new Proxy({}, EncodeProxy.handler(cf.definition)), val)\n  }\n\n  private static GroupFieldCheck (field: ContainedGroupField, val: any): object {\n    const accepted: boolean = Array.isArray(val) || !isNaN(val)\n    if (!accepted) {\n      throw new Error(`type ${field.name} is a group and needs array or number, not \"${typeof val}\"`)\n    }\n    const gf: ContainedComponentField = field as ContainedComponentField\n    const j: number = val\n    const isNumber: boolean = !isNaN(val)\n    if (isNumber) {\n      const arr: ILooseObject[] = new Array(j)\n      for (let i: number = 0; i < j; ++i) {\n        arr[i] = new Proxy({}, EncodeProxy.handler(gf.definition))\n      }\n      return arr\n    } else {\n      const arr: ILooseObject[] = val\n      for (let i: number = 0; i < arr.length; ++i) {\n        arr[i] = EncodeProxy.checkProperties(new Proxy({}, EncodeProxy.handler(gf.definition)), arr[i])\n      }\n      return arr\n    }\n  }\n\n  private static handler (set: ContainedFieldSet): Object {\n    return {\n      set (target: ILooseObject, prop: string, val: any): boolean {\n        const field: ContainedField = set.localNameToField.get(prop)\n        if (!field) {\n          throw new Error(`type ${set.name} has no field named ${prop}`)\n        }\n        target[prop] = EncodeProxy.examine(field, val)\n        return true\n      }\n    }\n  }\n\n  private static examine (field: ContainedField, val: any): any {\n    switch (field.type) {\n      case ContainedFieldType.Simple: {\n        EncodeProxy.SimpleFieldCheck(field as ContainedSimpleField, val)\n        break\n      }\n\n      case ContainedFieldType.Component: {\n        val = EncodeProxy.ComponentFieldCheck(field as ContainedComponentField, val)\n        break\n      }\n\n      case ContainedFieldType.Group: {\n        val = EncodeProxy.GroupFieldCheck(field as ContainedGroupField, val)\n        break\n      }\n    }\n    return val\n  }\n  public wrap (msgName: string): ILooseObject {\n    const msg: MessageDefinition = this.definitions.message.get(msgName)\n    if (!msg) {\n      throw new Error(`no message defined for type ${msgName}`)\n    }\n\n    return new Proxy({}, EncodeProxy.handler(msg))\n  }\n}\n"]}